#   		差分  	

## 			一维差分  	

- 对一维数组中连续数组进行修改，而且支持多次修改。

### 			计算项与项之间的差值  	

1

```
原始数组     0  0  0  0  0    a
```

2

```
差值数组     0  0  0  0  0    b       b[i] = a[i] - a[i-1]
```

3

```
=>                 
```

4

```
              
```

5

```
目的：    
```

6

```
           + 100
```

7

```
         --------
```

8

```
=>   0  |       |  0
```

9

```
     ①  ②   ③   ④  ⑤   
```

10

```
    
```

11

```
差值数组：   
```

12

```
     ①  ②
```

13

```
     |__|
```

14

```
   a[②]-a[①] = b[②]    +100 
```

15

```
                ④  ⑤   
```

16

```
                |__|
```

17

```
                a[⑤] - a[④] = b[⑤] -100
```

18

```
    
```

19

```
②  ~  ④    + 100
```

20

```
    b[②] += 100;
```

21

```
    b[⑤] -= 100;
```

22

```
    
```

23

```
原数组的改变，实际上可以理解为差值的改变     
```

### 			还原  	

- 新差值数组已经产生，那么如何还原？

1

```
  b[1]   b[2] .... b[n];
```

2

```
   |
```

3

```
 0 ~ 1
```

4

```
       
```

5

```
 a[1] - a[0] = b[1]
```

6

```
=> a[1] = a[0] + b[1];
```

7

```
=> a[2] = a[1] + b[2];
```

8

```
 
```

9

```
..
```

10

```
    a[i] = a[i - 1] + b[i];
```

#### 			C. 小 X 与煎饼达人(flip)  	

1

```
 0 0 0 0 ... 0
```

2

```
5次翻面：
```

3

```
     x1 ~ y1
```

4

```
     x2 ~ y2
```

5

```
   .....  
```

6

```
  1 ~ 8
```

7

```
  b[1] += 1;
```

8

```
  b[9] -= 1;
```

1

```
#include<bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
 
```

4

```
const int N = 1e6 + 10;
```

5

```
 
```

6

```
int a[N], b[N];
```

7

```
 
```

8

```
int main() {
```

9

```
 int n, k, i, l, r;
```

10

```
 cin >> n >> k;
```

11

```
 while (k --) {
```

12

```
  cin >> l >> r;
```

13

```
  // L    R
```

14

```
        // b[L]++  b[R + 1]--
```

15

```
        if (b[l] == 0) b[l] = 1;
```

16

```
  else b[l] = 0;
```

17

```
        
```

18

```
  if (b[r + 1] == 0) b[r + 1] = 1;
```

19

```
  else b[r + 1] = 0;
```

20

```
 }
```

21

```
 int ans = 0;
```

22

```
 for (i = 1 ; i <= n ; i ++) {
```

23

```
  a[i] = a[i - 1] + b[i];
```

24

```
  if (a[i] % 2 == 1) ans ++;
```

25

```
 }
```

26

```
 cout << ans;
```

27

```
 return 0;
```

28

```
}
```

#### 			B. 差分矩阵  	

1

```
#include <bits/stdc++.h>
```

2

```
#define ll long long
```

3

```
using namespace std;
```

4

```
const int N = 1e3 + 100;
```

5

```
ll n, m, q, a[N][N], b[N][N];
```

6

```
int main() {
```

7

```
 ll i, j, x1, y1, x2, y2, v;
```

8

```
 scanf("%lld%lld%lld", &n, &m, &q);
```

9

```
 for (i = 1 ; i <= n ; i ++) {
```

10

```
  for (j = 1 ; j <= m ; j ++) {
```

11

```
   scanf("%lld", &a[i][j]);
```

12

```
   //计算每一行的差值
```

13

```
   b[i][j] = a[i][j] - a[i][j - 1];
```

14

```
  }
```

15

```
 }
```

16

```
 while (q --) {
```

17

```
  scanf("%lld%lld%lld%lld%lld", &x1, &y1, &x2, &y2, &v);
```

18

```
  for (i = x1 ; i <= x2 ; i ++) {
```

19

```
   b[i][y1] += v;
```

20

```
   b[i][y2 + 1] -= v;
```

21

```
  }
```

22

```
 }
```

23

```
 for (i = 1 ; i <= n ; i ++) {
```

24

```
  for (j = 1 ; j <= m ; j ++) {
```

25

```
   a[i][j] = a[i][j - 1] + b[i][j];
```

26

```
   printf("%lld ", a[i][j]);
```

27

```
  }
```

28

```
  puts("");
```

29

```
 }
```

30

```
 return 0;
```

31

```
}
```

- 二维的差值

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
int n, m, k, q, e1, e2, s1, s2, a[1010][1010], b[1010][1010];
```

4

```
int main() {
```

5

```
 scanf("%d%d%d", &n, &m, &k);
```

6

```
 for (int i = 1; i <= n; i++) {
```

7

```
  for (int j = 1; j <= m; j++) {
```

8

```
   scanf("%d", &b[i][j]);
```

9

```
            // a数组记录差值 
```

10

```
   a[i][j] = b[i][j] - b[i - 1][j] - b[i][j - 1] + b[i - 1][j - 1];
```

11

```
     /*
```

12

```
       前缀和二维数组：
```

13

```
          b[i][j] = b[i-1][j] + b[i][j-1] - b[i-1][j-1] + a[i][j];
```

14

```
                =>
```

15

```
              差值：
```

16

```
              a[i][j] = b[i][j] - b[i-1][j] -  b[i][j-1] + b[i-1][j-1];
```

17

```
     */
```

18

```
        
```

19

```
        }
```

20

```
 }
```

21

```
    /*
```

22

```
     b[i][j] = b[i-1][j] + b[i][j-1] - b[i-1][j-1] + a[i][j];
```

23

```
     x1,y1 ~ x2,y2 + v
```

24

```
        
```

25

```
         (x1,y1)
```

26

```
           +v        =>    +v +v +v +V
```

27

```
                           +v +v +v +v
```

28

```
                           +v +v +v +v
```

29

```
                           +v +v +v +v
```

30

```
                
```

31

```
                
```

32

```
                                   (x1,y2+1)   
```

33

```
                  (x1,y1) [+v]      [-v]
```

34

```
                     
```

35

```
                                 [*](x2,y2)
```

36

```
                           
```

37

```
                    =>
```

38

```
差值数组：         
```

39

```
                                     (x1,y2+1)   
```

40

```
                  (x1,y1) [+v]       [-v]
```

41

```
                           
```

42

```
                                 [*](x2,y2)
```

43

```
                          [-v]
```

44

```
                          (x2+1,y1)
```

45

```
                    =>
```

46

```
                    
```

47

```
      
```

48

```
      
```

49

```
                                    (x1,y2+1)   
```

50

```
                  (x1,y1) [+v]       [-v]
```

51

```
                           
```

52

```
                                 [*](x2,y2)
```

53

```
                          [-v]       [+v]
```

54

```
                          (x2+1,y1)   (x2+1,y2+1)
```

55

```
                    =>
```

56

```
    */
```

57

```
 while (k--) {
```

58

```
  scanf("%d%d%d%d%d", &e1, &s1, &e2, &s2, &q);
```

59

```
  a[e1][s1] += q;
```

60

```
  a[e2 + 1][s1] -= q;
```

61

```
  a[e1][s2 + 1] -= q;
```

62

```
  a[e2 + 1][s2 + 1] += q;
```

63

```
 }
```

64

```
 for (int i = 1; i <= n; i++) {
```

65

```
  for (int j = 1; j <= m; j++) {
```

66

```
   b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + a[i][j];
```

67

```
   cout << b[i][j] << " ";
```

68

```
  }
```

69

```
  cout << endl;
```

70

```
 }
```

71

```
 return 0;
```

72

```
}
```

 

- 看作是一次差分修改

1

```
#include <bits/stdc++.h>
```

2

```
 
```

3

```
using namespace std;
```

4

```
const int N = 1010;
```

5

```
int a[N][N], b[N][N];
```

6

```
int n, m, q;
```

7

```
 
```

8

```
/**
```

9

```
 * 功能：二维差分构建
```

10

```
 * @param x1 左上角横坐标
```

11

```
 * @param y1 左上角纵坐标
```

12

```
 * @param x2 右下角横坐标
```

13

```
 * @param y2 右下角纵坐标
```

14

```
 * @param c  值
```

15

```
 */
```

16

```
void insert(int x1, int y1, int x2, int y2, int c) {
```

17

```
    b[x1][y1] += c;
```

18

```
    b[x2 + 1][y1] -= c;
```

19

```
    b[x1][y2 + 1] -= c;
```

20

```
    b[x2 + 1][y2 + 1] += c;
```

21

```
}
```

22

```
 
```

23

```
int main() {
```

24

```
    cin >> n >> m >> q;
```

25

```
    //读入并构建
```

26

```
    for (int i = 1; i <= n; i++)
```

27

```
        for (int j = 1; j <= m; j++)
```

28

```
            cin >> a[i][j], insert(i, j, i, j, a[i][j]);
```

29

```
 
```

30

```
    //q次区域变化
```

31

```
    while (q--) {
```

32

```
        int x1, y1, x2, y2, c;
```

33

```
        cin >> x1 >> y1 >> x2 >> y2 >> c;
```

34

```
        insert(x1, y1, x2, y2, c);
```

35

```
    }
```

36

```
    
```

37

```
    //还原二维数组
```

38

```
    for (int i = 1; i <= n; i++) {
```

39

```
        for (int j = 1; j <= m; j++) {//二维前缀和公式
```

40

```
            a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + b[i][j];
```

41

```
            printf("%d ", a[i][j]);
```

42

```
        }
```

43

```
        printf("\n");
```

44

```
    }
```

45

```
    return 0;
```

46

```
}
```

# 			二分  	

- 查找方法

- 折半查找

- 查找逻辑

  1

  ```
   
  ```

  2

  ```
     |________________________________|
  ```

  3

  ```
      1                            n
  ```

  4

  ```
      ↑     
  ```

  5

  ```
  朴素寻找：从最左端开始，循环遍历到最右端。
  ```

- 数据有序性

  - 确定查询的起点 `left`、终点 `right`

    - 找中间位置 `mid`

    1

    ```
       |______________?________________|
    ```

    2

    ```
        1                             n
    ```

    3

    ```
        ↑             ↑               ↑
    ```

    4

    ```
       left          mid             right
    ```

    5

    ```
         
    ```

    6

    ```
    mid = (left + right) / 2;
    ```

    7

    ```
     
    ```

    8

    ```
    if(a[mid] == x){
    ```

    9

    ```
        //找到
    ```

    10

    ```
        return 0;
    ```

    11

    ```
    }else if(a[mid] < x){
    ```

    12

    ```
        //
    ```

    13

    ```
    }else{
    ```

    14

    ```
        //
    ```

    15

    ```
    }
    ```

    16

    ```
     
    ```

  - 为什么需要有序？

    1

    ```
                    / 
    ```

    2

    ```
                 /    
    ```

    3

    ```
               / 
    ```

    4

    ```
             /
    ```

    5

    ```
           /
    ```

    6

    ```
         /
    ```

    7

    ```
       /                     
    ```

    8

    ```
     left    mid      right 
    ```

    9

    ```
                       
    ```

    10

    ```
    对于 一个升序序列， 必然满足 a[1] < a[2] < .... < a[n-1] < a[n]
    ```

    11

    ```
                        
    ```

    12

    ```
    找到x这个数了，必然满足
    ```

    13

    ```
     if(a[mid] == x){
    ```

    14

    ```
         ...
    ```

    15

    ```
     }else if(a[mid] < x){
    ```

    16

    ```
         
    ```

    17

    ```
         |——————————————|——————————————|
    ```

    18

    ```
        left           mid             right 
    ```

    19

    ```
                           |-----------|
    ```

    20

    ```
                     left = mid + 1    right
    ```

    21

    ```
                            
    ```

    22

    ```
     }else{
    ```

    23

    ```
         // a[mid] > x   
    ```

    24

    ```
         
    ```

    25

    ```
         x:101
    ```

    26

    ```
         
    ```

    27

    ```
         100            150            200
    ```

    28

    ```
          |——————————————|——————————————|
    ```

    29

    ```
        left           mid             right
    ```

    30

    ```
          |------------|
    ```

    31

    ```
                   right=mid-1
    ```

    32

    ```
     }
    ```

## 			等值查询   	

1

```
n: 6    x:888
```

2

```
 
```

3

```
    1   100  101  200  666  888  
```

4

```
    ①    ②    ③    ④    ⑤    ⑥
```

5

```
    |---------|--------------|
```

6

```
  left       mid             right
```

7

```
    
```

8

```
left:①
```

9

```
right:⑥    
```

10

```
mid: (① + ⑥) / 2 =>  ③
```

11

```
  
```

12

```
    1   100  101  200  666  888  
```

13

```
    ①    ②    ③    ④    ⑤    ⑥
```

14

```
    |---------|--------------|
```

15

```
  left       mid             right
```

16

```
                  ④          ⑥
```

17

```
                  |--- mid ---|
```

18

```
                left        right
```

19

```
                           
```

20

```
                             left
```

21

```
                             right
```

22

```
    
```

23

```
   left <= right  满足，那么一直寻找！ 
```

24

```
    
```

#### 			A. 二分查找  	

- 循环实现

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e6 + 100;
```

4

```
int a[N];
```

5

```
int main() {
```

6

```
 int n, i, x;
```

7

```
 // 有序递增数组
```

8

```
 scanf("%d", &n);
```

9

```
 for (i = 1 ; i <= n ; i ++) {
```

10

```
  scanf("%d", &a[i]);
```

11

```
 }
```

12

```
 scanf("%d", &x);
```

13

```
 //left 寻找的左边界  right 寻找的右边界
```

14

```
 int left = 1, right = n, mid;
```

15

```
 // 左边界 <= 右边界
```

16

```
 while (left <= right) {
```

17

```
  mid = (left + right) / 2;
```

18

```
  if (a[mid] == x) {
```

19

```
   printf("%d", mid);
```

20

```
   return 0;
```

21

```
  } else if (a[mid] < x) {
```

22

```
   left = mid + 1;
```

23

```
  } else {
```

24

```
   right = mid - 1;
```

25

```
  }
```

26

```
 }
```

27

```
 printf("%d", -1);
```

28

```
 return 0;
```

29

```
}
```

- 递归实现

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e6 + 100;
```

4

```
int a[N];
```

5

```
 
```

6

```
int find(int left, int right, int x) {
```

7

```
 if (left > right) return -1;
```

8

```
 int mid = (left + right) / 2;
```

9

```
 // 判断中心位置数值是否等于，如果等于就找到了。
```

10

```
 if (a[mid] == x) return mid;
```

11

```
 else if (a[mid] < x) return find(mid + 1, right, x);
```

12

```
 else return find(left, mid - 1, x);
```

13

```
}
```

14

```
 
```

15

```
int main() {
```

16

```
 int n, i, x;
```

17

```
 // 有序递增数组
```

18

```
 scanf("%d", &n);
```

19

```
 for (i = 1 ; i <= n ; i ++) {
```

20

```
  scanf("%d", &a[i]);
```

21

```
 }
```

22

```
 scanf("%d", &x);
```

23

```
 printf("%d", find(1, n, x));
```

24

```
 return 0;
```

25

```
}
```

## 			等值查询 - 边界查询  	

- 存在多个连续相同的数字

1

```
x:2  寻找最左侧的2 
```

2

```
    1 2 2 2 3 3
```

3

```
    ① ② ③ ④ ⑤ ⑥
```

4

```
    |___|______|
```

5

```
  left       right
```

6

```
        ↑
```

7

```
       mid
```

8

```
    |__|
```

9

```
 left right = mid - 1
```

10

```
    
```

11

```
if(a[mid] >= x){
```

12

```
    right = mid - 1;
```

13

```
}else{
```

14

```
    left = mid + 1;
```

15

```
}
```

16

```
 
```

17

```
    1 2 2 2  3 3
```

18

```
    ① ② ③ ④  ⑤  ⑥
```

19

```
    |___|______|
```

20

```
  left  mid   right
```

21

```
    ①         ⑥
```

22

```
    |_|
```

23

```
    l r
```

24

```
   mid
```

25

```
a[mid] < x   =>  l = mid + 1    
```

26

```
      ↑
```

27

```
      l  
```

28

```
      ②
```

29

```
 答案在 l 位置上，并且 a[l] == x！
```

30

```
        
```

## 			近似值查找  	

- 找到从左往右第一个大于等于x的数值

  1

  ```
  x : 2        
  ```

  2

  ```
   1  3  4  5  6
  ```

  3

  ```
   |___________|
  ```

  4

  ```
   L     M      R
  ```

  5

  ```
    
  ```

  6

  ```
  a[M] > x   无法判断是不是第一个大于x的数值    
  ```

  7

  ```
    R = M - 1 
  ```

  8

  ```
   ↑  ↑
  ```

  9

  ```
   L  R   
  ```

  10

  ```
   M
  ```

  11

  ```
      ↑
  ```

  12

  ```
      L    
  ```

  13

  ```
      
  ```

  14

  ```
  答案在 l 位置上！    
  ```

**2023.10.2 二分查询**

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e5 + 100;
```

4

```
int a[N], n;
```

5

```
 
```

6

```
int find(int l, int r, int x) {
```

7

```
 int m = (l + r) / 2;
```

8

```
 while (l <= r) {
```

9

```
  m = (l + r) / 2;
```

10

```
  // 如果中间的数值 大于等于x 往左寻找
```

11

```
  if (a[m] >= x) {
```

12

```
   r = m - 1;
```

13

```
  } else {
```

14

```
   // 如果中间的数值 小于x 往右寻找
```

15

```
   l = m + 1;
```

16

```
  }
```

17

```
 }
```

18

```
 // 在 1 ~ n 的范围中，存在等值左边界 l
```

19

```
 return l >= 1 && l <= n && a[l] == x ? l : -1;
```

20

```
}
```

21

```
 
```

22

```
int main() {
```

23

```
 scanf("%d", &n);
```

24

```
 for (int i = 1 ; i <= n ; i ++) {
```

25

```
  scanf("%d", &a[i]);
```

26

```
 }
```

27

```
 int q, x;
```

28

```
 scanf("%d", &q);
```

29

```
 while (q --) {
```

30

```
  scanf("%d", &x);
```

31

```
  printf("%d ", find(1, n, x));
```

32

```
 }
```

33

```
 return 0;
```

34

```
}
```