# 前缀和  	

#### 			E. 信号塔  	

![image-20231027184150636](http://0519os.comc/Users/wsjsz/AppData/Roaming/Typora/typora-user-images/image-20231027184150636.png)

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e5 + 100;
```

4

```
/*
```

5

```
  损坏的信号塔，都设置为1
```

6

```
*/
```

7

```
int a[N], b[N];
```

8

```
 
```

9

```
int main() {
```

10

```
 int n, l, m, i, x, s, mi = 999999;
```

11

```
 scanf("%d%d%d", &n, &l, &m);
```

12

```
 for (i = 1 ; i <= m ; i ++) {
```

13

```
  scanf("%d", &x);
```

14

```
  a[x] = 1;
```

15

```
 }
```

16

```
 //前缀和求和数组
```

17

```
 for (i = 1 ; i <= n ; i ++) {
```

18

```
  b[i] = b[i - 1] + a[i];
```

19

```
 }
```

20

```
 //l截取 枚举起始位置
```

21

```
 for (i = 1 ; i <= n - l + 1 ; i ++) {
```

22

```
  s = b[i + l - 1] - b[i - 1];
```

23

```
  mi = min(mi, s);
```

24

```
 }
```

25

```
 printf("%d", mi);
```

26

```
 return 0;
```

27

```
}
```

# 			差分  	

- 步骤
  - 计算项与项之间的差值
  - 修改指定位置的数值
  - 恢复数列

1

```
     ______
```

2

```
    |      |
```

3

```
————|      |----     
```

4

```
     x    y y+1    
```

5

```
  |__↑    |__↑
```

6

```
         
```

7

```
 x-1 x      x 与 x-1 项的差值发生了改变。     
```

#### 			C. 小 X 与煎饼达人(flip)  	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e6 + 100;
```

4

```
int a[N], b[N];
```

5

```
/*
```

6

```
  差分
```

7

```
   ① 计算项与项之间的差值
```

8

```
   ② 指定项的修改
```

9

```
*/
```

10

```
int main() {
```

11

```
 int n, m, i, x, y;
```

12

```
 cin >> n >> m;
```

13

```
 for (i = 1 ; i <= m ; i ++) {
```

14

```
  cin >> x >> y;
```

15

```
  /*
```

16

```
      x  , y + 1 修改
```

17

```
   */
```

18

```
  a[x] += 1;
```

19

```
  a[y + 1] -= 1;
```

20

```
 }
```

21

```
 int ans = 0;
```

22

```
 //修改差值之后，再次计算前缀和 => 恢复
```

23

```
 for (i = 1 ; i <= n ; i ++) {
```

24

```
  b[i] = b[i - 1] + a[i];
```

25

```
  if (b[i] % 2 == 1) ans ++;
```

26

```
 }
```

27

```
 cout << ans;
```

28

```
 return 0;
```

29

```
}
```

# 			图论  	

#### 			E. 开会  	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1100;
```

4

```
int a[N][N], n;
```

5

```
bool vis[N];
```

6

```
//w有部队的村庄编号 cnt统计到达该村庄的部队的个数
```

7

```
int w[N], cnt[N];
```

8

```
 
```

9

```
void dfs(int x) {
```

10

```
 //标记走过
```

11

```
 vis[x] = 1;
```

12

```
 cnt[x] ++;
```

13

```
 for (int k = 1 ; k <= n ; k ++) {
```

14

```
  if (!vis[k] && a[x][k] == 1) {
```

15

```
   dfs(k);
```

16

```
  }
```

17

```
 }
```

18

```
}
```

19

```
 
```

20

```
int main() {
```

21

```
 //k部队数 n结点个数 m边条数
```

22

```
 int k, m, i, x, y;
```

23

```
 cin >> k >> n >> m;
```

24

```
 for (i = 1 ; i <= k ; i ++) {
```

25

```
  cin >> w[i];
```

26

```
 }
```

27

```
 //图的记录
```

28

```
 for (i = 1 ; i <= m ; i ++) {
```

29

```
  cin >> x >> y;
```

30

```
  a[x][y] = 1;
```

31

```
 }
```

32

```
 for (i = 1; i <= k ; i ++) {
```

33

```
  x = w[i];
```

34

```
  memset(vis, 0, sizeof(vis));
```

35

```
  //搜索的起点
```

36

```
  dfs(x);
```

37

```
 }
```

38

```
 //符合开会的地点个数
```

39

```
 int ans = 0;
```

40

```
 for (i = 1 ; i <= n ; i ++) {
```

41

```
  if (cnt[i] == k) {
```

42

```
   ans ++;
```

43

```
  }
```

44

```
 }
```

45

```
 cout << ans;
```

46

```
 return 0;
```

47

```
}
```

#### 			F. 路径查找  	

- 思路：
  - 存储
  - 搜索
  - 到达终点的打印

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 110;
```

4

```
int a[N][N], n, m, r[N], c;  // c:输出条数
```

5

```
bool vis[N]; //vis:搜索中搜过的结点
```

6

```
 
```

7

```
void dfs(int x, int d) {
```

8

```
 if (c >= 1000) return;
```

9

```
 // 封路
```

10

```
 vis[x] = 1;
```

11

```
 // 第d步，到达的结点是 x
```

12

```
 r[d] = x;
```

13

```
 // 打印
```

14

```
 if (x == n) {
```

15

```
  c ++; // 输出条数
```

16

```
  //路径打印
```

17

```
  for (int k = 1 ; k <= d ; k ++) {
```

18

```
   cout << r[k] << " ";
```

19

```
  }
```

20

```
  cout << endl;
```

21

```
 } else {
```

22

```
  // 下一个结点的可能范围
```

23

```
  for (int k = 1 ; k <= n ; k ++) {
```

24

```
   if (!vis[k] && a[x][k]) {
```

25

```
    dfs(k, d + 1);
```

26

```
   }
```

27

```
  }
```

28

```
 }
```

29

```
 //解封
```

30

```
 vis[x] = 0;
```

31

```
}
```

32

```
 
```

33

```
int main() {
```

34

```
 cin >> n >> m;
```

35

```
 int x, y;
```

36

```
 for (int i = 1 ; i <= m ; i ++) {
```

37

```
  cin >> x >> y;
```

38

```
  a[x][y] = a[y][x] = 1;
```

39

```
 }
```

40

```
 dfs(1, 1);
```

41

```
 return 0;
```

42

```
}
```

# 			图论中最短路  	

- 图中从一个结点开始，到另一个结点结束。
  - 找出最短距离
- 图中，点与点之间有路线的长度 （权值）。

## 			单源最短路  	

- 从一个起点出发，到达每一个结点的最少的距离求解。

- 思路

  - 初始状态下，认为从起点出发，到达其他的每一个结点的最短距离都是 `INT_MAX`。
    - 源头到每一个结点都是无法到达的。
  - 搜索的过程中，不断进行比较、更新。

- 程序结构

  - `int dis[N];` distance 距离

    1

    ```
    for(int i = 1 ; i <= n ; i ++){
    ```

    2

    ```
        dis[i] = INT_MAX;             //  dis[i] = 0x3f3f3f3f; 
    ```

    3

    ```
    }
    ```

  - 搜索中更新

    - 三角不等式

      1

      ```
                   x
      ```

      2

      ```
                 /   \
      ```

      3

      ```
      s ....... /.....\ k
      ```

      4

      ```
       
      ```

      5

      ```
        dis[x] + g[x][k] < dis[k]
      ```

    1

    ```
    int g[N][N];
    ```

    2

    ```
     
    ```

    3

    ```
    ...
    ```

    4

    ```
     
    ```

    5

    ```
    // x:到达结点  s:到达累加距离
    ```

    6

    ```
    void dfs(int x,int s){
    ```

    7

    ```
        dis[x] = s;
    ```

    8

    ```
        // 遍历下一轮的每一个结点
    ```

    9

    ```
        for(int k = 1 ; k <= n ; k ++){
    ```

    10

    ```
            // ① 连通性 ② 最短路比较
    ```

    11

    ```
            //保证 s -> x -> k  距离能收缩 (s -> k)
    ```

    12

    ```
            // dis[x]:表示起点到达 x 点的最短距离
    ```

    13

    ```
            // dis[k]:表示起点到达 k 点的最短距离
    ```

    14

    ```
            // g[x][k]: 表示 结点 x 到 k 的直接距离
    ```

    15

    ```
            if(g[x][k] && dis[x] + g[x][k] < dis[k]){
    ```

    16

    ```
                dfs(k , dis[x] + g[x][k]);
    ```

    17

    ```
            }
    ```

    18

    ```
        }
    ```

    19

    ```
    }
    ```

    #### 							A. 城市之间的最短路  					

    ![image-20231027205445149](http://0519os.comc/Users/wsjsz/AppData/Roaming/Typora/typora-user-images/image-20231027205445149.png)

    - `g[x][k] == 0` 表示 �

      结点无法直接连接 

      �

      

    1

    ```
    #include <bits/stdc++.h>
    ```

    2

    ```
    using namespace std;
    ```

    3

    ```
    const int N = 11;
    ```

    4

    ```
    int g[N][N], n, m, dis[N]; //起点到每一个点最少距离
    ```

    5

    ```
    // 到达的结点 x ，累计的距离 sum
    ```

    6

    ```
    void dfs(int x, int sum) {
    ```

    7

    ```
     dis[x] = sum;
    ```

    8

    ```
     for (int k = 1 ; k <= n ; k ++) {
    ```

    9

    ```
      // x → k
    ```

    10

    ```
      if (g[x][k] && dis[x] + g[x][k] < dis[k]) {
    ```

    11

    ```
       // x (sum) -> g[x][k] ->  k (sum + g[x][k])
    ```

    12

    ```
       dfs(k, dis[x] + g[x][k]);
    ```

    13

    ```
      }
    ```

    14

    ```
     }
    ```

    15

    ```
    }
    ```

    16

    ```
     
    ```

    17

    ```
    int main() {
    ```

    18

    ```
     cin >> n >> m;
    ```

    19

    ```
     int x, y, z, s, e;
    ```

    20

    ```
     // 到达每一个结点，最少距离都是∞
    ```

    21

    ```
     for (int i = 1 ; i <= n ; i ++) {
    ```

    22

    ```
      dis[i] = INT_MAX / 2;
    ```

    23

    ```
     }
    ```

    24

    ```
     for (int i = 1 ; i <= m ; i ++) {
    ```

    25

    ```
      cin >> x >> y >> z;
    ```

    26

    ```
      g[x][y] = z;
    ```

    27

    ```
      g[y][x] = z;
    ```

    28

    ```
     }
    ```

    29

    ```
     cin >> s >> e;
    ```

    30

    ```
     dfs(s, 0);
    ```

    31

    ```
     //s -> e  起点出发，没有到达过 e， dis[e] => INT_MAX
    ```

    32

    ```
     if (dis[e] == INT_MAX / 2) cout << "No path";
    ```

    33

    ```
     else cout << dis[e];
    ```

    34

    ```
     return 0;
    ```

    35

    ```
    }
    ```

     

     