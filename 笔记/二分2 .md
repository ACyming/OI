# 二分查询  	

- 数据量较大时，采用二分查询的方法。

- 数列的数值，一定有序。 （一般情况下，从小到大）

- �(����)

  

- `l`、`r`、`mid`

## 			等值查询  	

和为给定数

1

```
  x          y
```

2

```
  |__________|    x + y == m
```

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e5 + 10;
```

4

```
int a[N], n;
```

5

```
int find(int x) {
```

6

```
 int l = 1, r = n, mid;
```

7

```
 while (l <= r) {
```

8

```
  mid = (l + r) / 2;
```

9

```
  if (a[mid] == x) {
```

10

```
   return mid;
```

11

```
  } else if (a[mid] < x) {
```

12

```
   l = mid + 1;
```

13

```
  } else {
```

14

```
   r = mid - 1;
```

15

```
  }
```

16

```
 }
```

17

```
 return -1;
```

18

```
}
```

19

```
int main() {
```

20

```
 int i, m, x, y, k;
```

21

```
 scanf("%d", &n);
```

22

```
 for (i = 1 ; i <= n ; i ++) {
```

23

```
  scanf("%d", &a[i]);
```

24

```
 }
```

25

```
 sort(a + 1, a + 1 + n);
```

26

```
 scanf("%d", &m);
```

27

```
 for (i = 1 ; i <= n ; i ++) {
```

28

```
  x = a[i];
```

29

```
  y = m - x;
```

30

```
  if (x > y) break;
```

31

```
  k = find(y);
```

32

```
  // 不能找到的是自己位置
```

33

```
  if (k != -1 && k != i) {
```

34

```
   printf("%d %d\n", x, y);
```

35

```
   return 0;
```

36

```
  }
```

37

```
 }
```

38

```
 puts("No");
```

39

```
 return 0;
```

40

```
}
```

 

## 			左侧、右侧边界值  	

1

```
 1  2  2  2  3
```

2

```
    ↑
```

3

```
 ↑     ↑     ↑
```

4

```
 l    mid    r
```

5

```
 ①     ③      ⑤    
```

6

```
  
```

7

```
以左边界查询为例：
```

8

```
     如果 a[mid] == x  （中心位置的数值 等于要查询的 x，那么往左侧查询 ， 无法确定是不是最左边）
```

9

```
认为不是最左边：r = mid - 1;
```

10

```
         a[mid] > x   （中心位置的数值 大于要查询的 x，那么往左查询 ： r = mid - 1; 
```

11

```
 
```

12

```
     |_______________|
```

13

```
                    l      mid      r    
```

14

```
                          |
```

15

```
                          r
```

16

```
                    |_____|    
```

17

```
x:2
```

18

```
 1  2  2  2  3
```

19

```
    ↑
```

20

```
 ↑     ↑     
```

21

```
 l    mid    
```

22

```
 ①     ③      ⑤    
```

23

```
    ↑   
```

24

```
    r
```

25

```
    ②
```

26

```
 |__|
```

27

```
mid   
```

28

```
    a[mid] < x :  中心点的数值 小于了 x，则表示需要的答案在右侧，往右侧移动： l = mid + 1；
```

29

```
    
```

30

```
       |_______________|
```

31

```
                    l      mid      r    
```

32

```
                              |_____|
```

33

```
                              l     r
```

- 程序实现

  1

  ```
   // l变量 <= r变量  l在r的左侧或者 l与r重叠
  ```

  2

  ```
   while(l <= r){
  ```

  3

  ```
       mid = (l + r) / 2;
  ```

  4

  ```
       if(a[mid] >= x){   // 左移动
  ```

  5

  ```
           r = mid - 1;
  ```

  6

  ```
       }else{
  ```

  7

  ```
           l = mid + 1;
  ```

  8

  ```
       }
  ```

  9

  ```
   }    
  ```

  - 循环的结束 (�>�)

    

    1

    ```
    x:2
    ```

    2

    ```
     1  2  2  2  3
    ```

    3

    ```
     ↑     ↑     
    ```

    4

    ```
     l    mid    
    ```

    5

    ```
     ①     ③      ⑤    
    ```

    6

    ```
        ↑   
    ```

    7

    ```
        r
    ```

    8

    ```
        ②
    ```

    9

    ```
     |__|
    ```

    10

    ```
     ↑   
    ```

    11

    ```
    mid
    ```

    12

    ```
      
    ```

    13

    ```
    a[mid] < x :  l = mid + 1    
    ```

    14

    ```
        
    ```

    15

    ```
     1  2  2  2  3
    ```

    16

    ```
     ↑     ↑     
    ```

    17

    ```
     l    mid            (1)
    ```

    18

    ```
     ①     ③      ⑤    
    ```

    19

    ```
        ↑   
    ```

    20

    ```
        r
    ```

    21

    ```
        ②
    ```

    22

    ```
     |__|                (2)
    ```

    23

    ```
     ↑   
    ```

    24

    ```
    mid
    ```

    25

    ```
        ↑  
    ```

    26

    ```
        l               (3)
    ```

    27

    ```
     
    ```

    28

    ```
    //   l: 1 ~ n 表示存在 <= x 的数，l 就是 x 往左第一个满足 <= x 的位置！
    ```

    29

    ```
    //   a[l] == x
    ```

    30

    ```
    if(l >= 1 && l <= n && a[l] == x){
    ```

    31

    ```
        
    ```

    32

    ```
    } else{
    ```

    33

    ```
        //① l >= 1 && l <= n && a[l] != x   能找到 < x 的数 ，但是找不到 == x的数值。
    ```

    34

    ```
        //② l < 1  || l > n  找不到 （a[mid] <= x）
    ```

    35

    ```
    }   
    ```

#### 			E. 小X算排名  	

- 左边界查询

  1

  ```
  |\
  ```

  2

  ```
  |  \
  ```

  3

  ```
  |    \
  ```

  4

  ```
  -------  
  ```

  5

  ```
  a:  95  100  99  99  96  
  ```

  6

  ```
  b:  95  100  99  99  96
  ```

  7

  ```
  => a:从大到小序列中：找第一次出现的位置    
  ```

  8

  ```
  a:  100  99  99  96  95    
  ```

  9

  ```
       ①   ②       ④    ⑤
  ```

  10

  ```
      
  ```

  11

  ```
  b数组中的每一个数值都去a数组中，找左起第一次出现的位置。    
  ```

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e5 + 100;
```

4

```
int a[N], b[N], n;
```

5

```
 
```

6

```
bool cmp(int x, int y) {
```

7

```
 return x > y;
```

8

```
}
```

9

```
// 左侧边界值
```

10

```
int find(int x) {
```

11

```
 int l = 1, r = n, mid;
```

12

```
 while (l <= r) {
```

13

```
  mid = (l + r) / 2;
```

14

```
  if (a[mid] <= x) r = mid - 1;
```

15

```
  else l = mid + 1;
```

16

```
 }
```

17

```
 return l;
```

18

```
}
```

19

```
 
```

20

```
int main() {
```

21

```
 scanf("%d", &n);
```

22

```
 for (int i = 1 ; i <= n ; i ++) {
```

23

```
  scanf("%d", &a[i]);
```

24

```
  b[i] = a[i];
```

25

```
 }
```

26

```
 sort(a + 1, a + 1 + n, cmp);
```

27

```
 int x;
```

28

```
 for (int i = 1 ; i <= n ; i ++) {
```

29

```
  x = b[i];
```

30

```
  printf("%d\n", find(x));
```

31

```
 }
```

32

```
 return 0;
```

33

```
}
```

 

## 			次数查询  	

- 查询 �

  这个数字在不降序列 

  1−�

   

  中，出现的次数

  

1

```
问：下面的数列中，x=2 x出现的次数 ？ 
```

2

```
 1  2  2  2  3
```

3

```
          
```

4

```
 ①  ②  ③  ④  ⑤  
```

5

```
    p     q
```

6

```
    |_____|
```

7

```
p:左边界
```

8

```
q:右边界
```

9

```
    
```

10

```
cnt = q - p + 1     
```

11

```
    
```

#### 			J. 指定数出现的次数  	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e5 + 100;
```

4

```
int a[N], n;
```

5

```
int main() {
```

6

```
 int i, k, x, p, q;
```

7

```
 //n:数列的个数  k:询问的次数
```

8

```
 scanf("%d%d", &n, &k);
```

9

```
 for (i = 1 ; i <= n ; i ++) {
```

10

```
  //每一个数字读入数组
```

11

```
  scanf("%d", &a[i]);
```

12

```
 }
```

13

```
 //从小到大排序
```

14

```
 sort(a + 1, a + 1 + n);
```

15

```
 //循环k次
```

16

```
 for (i = 1 ; i <= k ; i ++) {
```

17

```
  scanf("%d", &x);
```

18

```
  //左侧边界： 数值相同的最左边的位置
```

19

```
  int l = 1, r = n, mid;
```

20

```
  while (l <= r) {
```

21

```
   mid = (l + r) / 2;
```

22

```
   if (a[mid] >= x) {
```

23

```
    r = mid - 1;
```

24

```
   } else {
```

25

```
    l = mid + 1;
```

26

```
   }
```

27

```
  }
```

28

```
  if (l >= 1 && l <= n && a[l] == x) p = l;
```

29

```
  else {
```

30

```
   printf("%d ", 0);
```

31

```
   continue;
```

32

```
  }
```

33

```
  //右侧边界： 数值相同的最右边的位置
```

34

```
  l = 1, r = n;
```

35

```
  while (l <= r) {
```

36

```
   mid = (l + r) / 2;
```

37

```
   if (a[mid] <= x) {
```

38

```
    l = mid + 1;
```

39

```
   } else {
```

40

```
    r = mid - 1;
```

41

```
   }
```

42

```
  }
```

43

```
  if (r >= 1 && r <= n && a[r] == x) q = r;
```

44

```
  printf("%d ", q - p + 1);
```

45

```
 }
```

46

```
 return 0;
```

47

```
}
```

48

```
 
```

49

```
 
```

### 			**2661 - 差为给定的数**  	

1

```
#include <bits/stdc++.h>
```

2

```
#define ll long long
```

3

```
using namespace std;
```

4

```
const int N = 2e5 + 100;
```

5

```
ll a[N];
```

6

```
int main() {
```

7

```
 ll n, t, i, x, y, p, q, cnt = 0;
```

8

```
 scanf("%lld%lld", &n, &t);
```

9

```
 for (i = 1 ; i <= n ; i ++) {
```

10

```
  scanf("%lld", &a[i]);
```

11

```
 }
```

12

```
 //从小到大排序
```

13

```
 sort(a + 1, a + 1 + n);
```

14

```
 for (i = 1 ; i <= n ; i ++) {
```

15

```
  x = a[i];
```

16

```
  y = x + t;
```

17

```
  //左侧边界
```

18

```
  int l = i + 1, r = n, mid;
```

19

```
  while (l <= r) {
```

20

```
   mid = (l + r) / 2;
```

21

```
   if (a[mid] >= y) {
```

22

```
    r = mid - 1;
```

23

```
   } else {
```

24

```
    l = mid + 1;
```

25

```
   }
```

26

```
  }
```

27

```
  if (l >= 1 && l <= n && a[l] == y) p = l;
```

28

```
  else continue;
```

29

```
  //右侧边界
```

30

```
  l = i + 1, r = n;
```

31

```
  while (l <= r) {
```

32

```
   mid = (l + r) / 2;
```

33

```
   if (a[mid] <= y) {
```

34

```
    l = mid + 1;
```

35

```
   } else {
```

36

```
    r = mid - 1;
```

37

```
   }
```

38

```
  }
```

39

```
  if (r >= 1 && r <= n && a[r] == y) q = r;
```

40

```
  cnt += q - p + 1;
```

41

```
 }
```

42

```
 printf("%lld", cnt);
```

43

```
 return 0;
```

44

```
}
```

45

```
 
```

46

```
 
```

# 			二分答案  	

- 通过二分的方法，寻找最合适的数值。

- 满足单调性

  1

  ```
  ①  某一个位置，往后的每一个位置都符合
  ```

  2

  ```
   
  ```

  3

  ```
      |____________________|
  ```

  4

  ```
            √  √  √  √  √ √
  ```

  5

  ```
            ↑
  ```

  6

  ```
         最小的合适的答案
  ```

  7

  ```
      
  ```

  8

  ```
  ②  某一个位置，往前的每一个位置都符合        
  ```

  9

  ```
      
  ```

  10

  ```
      |_____________________|
  ```

  11

  ```
       √  √  √  √  
  ```

  12

  ```
                ↑
  ```

  13

  ```
           最大的合适的答案
  ```

#### 			K. 游船分配  	

1

```
 
```

2

```
i --    mid
```

3

```
    |_________|
```

4

```
    l         r
```

5

```
   (i+1)     (n)  
```

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 5e4 + 100;
```

4

```
int a[N], n, m;
```

5

```
// p合适的位置  右侧边界值
```

6

```
bool check(int k, int p) {
```

7

```
 return a[k] + a[p] <= m;
```

8

```
}
```

9

```
 
```

10

```
int main() {
```

11

```
 int l, r, mid, cnt = 0;
```

12

```
 scanf("%d%d", &n, &m);
```

13

```
 for (int i = 1 ; i <= n ; i ++) {
```

14

```
  scanf("%d", &a[i]);
```

15

```
 }
```

16

```
 sort(a + 1, a + 1 + n);
```

17

```
 for (int i = 1 ; i <= n ; i ++) {
```

18

```
  l = i + 1, r = n;
```

19

```
  while (l <= r) {
```

20

```
   // i:分组第一位的位置   l ~ r
```

21

```
   mid = (l + r) / 2;
```

22

```
   if (check(i, mid)) {
```

23

```
    l = mid + 1;
```

24

```
   } else {
```

25

```
    r = mid - 1;
```

26

```
   }
```

27

```
  }
```

28

```
  //r符合的位置
```

29

```
  cnt += r - i;
```

30

```
 }
```

31

```
 printf("%d", cnt);
```

32

```
 return 0;
```

33

```
}
```

#### 			A. 伐木工  	

1

```
                    |
```

2

```
       |            |         ↑      
```

3

```
       |     |      |         H
```

4

```
       |     |      |         ↓
```

5

```
                        
```

6

```
 满足：砍伐的总长度 >= m 的情况下， H 的最大的设置高度是多少 ?
```

7

```
 单调性： 伐木机越高，砍伐的总量越少 !    
```

8

```
                                              
```

- 判断某一个高度，是否能够砍伐到 m 的总长 (s >= m)。

  1

  ```
  bool check(int h){
  ```

  2

  ```
      int s = 0,i;
  ```

  3

  ```
      // 从第一棵树开始，到第n棵树，把每一棵树的砍伐总量累加 >= m，说明这个高度h -> ok
  ```

  4

  ```
      for(i = 1 ; i <= n ; i ++){
  ```

  5

  ```
          if(a[i] > h){
  ```

  6

  ```
          s = s + a[i] - h;    
  ```

  7

  ```
          if(s >= m) return true;
  ```

  8

  ```
          }
  ```

  9

  ```
      }
  ```

  10

  ```
      // 如果砍伐总长s >= 需求量m , 则设定的高度h -> OK
  ```

  11

  ```
      return s >= m;
  ```

  12

  ```
  }
  ```

- 二分里判断可行还是不可行

  1

  ```
  最小高度:  |_____________________|最大高度
  ```

  2

  ```
             √  √  √  √  
  ```

  3

  ```
                      ↑
  ```

  4

  ```
                最大的合适的答案
  ```

  5

  ```
   
  ```

  6

  ```
   
  ```

  7

  ```
  二分猜【伐木机设置的合适高度】 
  ```

  8

  ```
   初始状态下：
  ```

  9

  ```
   l : 0   贴着地面切割
  ```

  10

  ```
   r : 最大树高度 a[i] 
  ```

  11

  ```
   while(l <= r){
  ```

  12

  ```
       mid = (l + r) / 2;
  ```

  13

  ```
       // mid:猜高度
  ```

  14

  ```
       if(check(mid)){
  ```

  15

  ```
           // 如果以 mid 的高度切割，能够得到 >= m 的总量 ，说明伐木机的高度还可以更高！
  ```

  16

  ```
           l = mid + 1;
  ```

  17

  ```
       }else{
  ```

  18

  ```
           r = mid - 1;
  ```

  19

  ```
       }
  ```

  20

  ```
   }
  ```

  21

  ```
   
  ```

  22

  ```
  .....r
  ```

1

```
#include <bits/stdc++.h>
```

2

```
#define ll long long
```

3

```
using namespace std;
```

4

```
const int N = 1e6 + 10;
```

5

```
ll a[N], n, m, ma;
```

6

```
 
```

7

```
bool check(ll h) {
```

8

```
 ll s = 0, i;
```

9

```
 for (i = 1 ; i <= n ; i ++) {
```

10

```
  if (a[i] > h) {
```

11

```
   s += a[i] - h;
```

12

```
   if (s >= m) return true;
```

13

```
  }
```

14

```
 }
```

15

```
 return s >= m;
```

16

```
}
```

17

```
 
```

18

```
int main() {
```

19

```
 scanf("%lld%lld", &n, &m);
```

20

```
 for (int i = 1 ; i <= n ; i ++) {
```

21

```
  scanf("%lld", &a[i]);
```

22

```
  //求解出树木的最大值
```

23

```
  ma = max(ma, a[i]);
```

24

```
 }
```

25

```
 //二分：排序
```

26

```
 // 伐木机高度 0 ~ ma
```

27

```
 ll l = 0, r = ma, mid;
```

28

```
 while (l <= r) {
```

29

```
  mid = (l + r) / 2;
```

30

```
  //mid 猜的伐木机的高度
```

31

```
  if (check(mid)) {
```

32

```
   l = mid + 1;
```

33

```
  } else {
```

34

```
   r = mid - 1;
```

35

```
  }
```

36

```
 }
```

37

```
 printf("%lld", r);
```

38

```
 return 0;
```

39

```
}
```

 