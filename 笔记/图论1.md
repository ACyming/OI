# 	图论  	

- 一种数据结构
  - 点与点之间的连接关系

1

```
 *       *
```

2

```
   \   /
```

3

```
     *
```

4

```
      \
```

5

```
        *
```

6

```
     
```

7

```
   *     *-*    *
```

8

```
                |   ....
```

9

```
                *
```

## 			图的分类  	

- 有向图

  - 结点之间的连线有方向性。

    1

    ```
     * → *
    ```

    2

    ```
     A   B
    ```

    3

    ```
         
    ```

    4

    ```
       --------------
    ```

    5

    ```
    A   → → → → → → →   B 
    ```

    6

    ```
       --------------
    ```

    7

    ```
         
    ```

    8

    ```
         >
    ```

    9

    ```
      A     B
    ```

    10

    ```
         <     
    ```

- 无向图

  - 结点之间连线没有方向，意味着双向。

    1

    ```
     * -- *
    ```

    2

    ```
     A   B
    ```

    3

    ```
         
    ```

    4

    ```
       --------------
    ```

    5

    ```
    A   ------------   B 
    ```

    6

    ```
       --------------  
    ```

## 			图的存储  	

### 			邻接矩阵  	

- 结点与结点之间的关系

- 矩阵 → 二维数组

  - 有向图 (非对称)

    1

    ```
      1 → 2 → 4 
    ```

    2

    ```
      ↓       ↓
    ```

    3

    ```
      3   →   5
    ```

    4

    ```
          
    ```

    5

    ```
    1 → 2 
    ```

    6

    ```
    2 → 4
    ```

    7

    ```
    1 → 3
    ```

    8

    ```
    4 → 5
    ```

    9

    ```
    3 → 5   
    ```

  - 5×5

    表格

    

    1

    ```
    int g[N][N];  // N 结点的最大值
    ```

    2

    ```
     
    ```

    3

    ```
    1:表示连通
    ```

    4

    ```
    0:表示不连通  
    ```

    5

    ```
        
    ```

    6

    ```
    g[1][2] = 1;
    ```

    7

    ```
    g[2][4] = 1;
    ```

    8

    ```
    g[1][3] = 1;
    ```

    9

    ```
    g[4][5] = 1;
    ```

    10

    ```
    g[3][5] = 1;
    ```

  |      | 1    | 2    | 3    | 4    | 5    |
  | :--- | :--- | :--- | :--- | :--- | :--- |
  | 1    | 0    | 1    | 1    | 0    | 0    |
  | 2    | 0    | 0    | 0    | 1    | 0    |
  | 3    | 0    | 0    | 0    | 0    | 1    |
  | 4    | 0    | 0    | 0    | 0    | 1    |
  | 5    | 0    | 0    | 0    | 0    | 0    |

  - 无向图

  1

  ```
    1 - 2 - 4 
  ```

  2

  ```
    |       |
  ```

  3

  ```
    3   -   5
  ```

  4

  ```
        
  ```

  5

  ```
  1 - 2 
  ```

  6

  ```
  2 - 4
  ```

  7

  ```
  1 - 3
  ```

  8

  ```
  4 - 5
  ```

  9

  ```
  3 - 5    
  ```

  - 5×5

    表格

    

    1

    ```
    int g[N][N];  // N 结点的最大值
    ```

    2

    ```
     
    ```

    3

    ```
    1:表示连通
    ```

    4

    ```
    0:表示不连通  
    ```

    5

    ```
        
    ```

    6

    ```
    g[1][2] = g[2][1] = 1;
    ```

    7

    ```
    g[2][4] = g[4][2] = 1;
    ```

    8

    ```
    g[1][3] = g[3][1] = 1;
    ```

    9

    ```
    g[4][5] = g[5][4] = 1;
    ```

    10

    ```
    g[3][5] = g[5][3] = 1;
    ```

    |      | 1    | 2    | 3    | 4    | 5    |
    | :--- | :--- | :--- | :--- | :--- | :--- |
    | 1    |      | 1    | 1    |      |      |
    | 2    | 1    |      |      | 1    |      |
    | 3    | 1    |      |      |      | 1    |
    | 4    |      | 1    |      |      | 1    |
    | 5    |      |      | 1    | 1    |      |

### 			图的遍历  	

- 走一个完整的图
  - 规定搜索的起点，搜索每一个结点。

#### 			搜索  	

##### 			深度优先搜索 `DFS`  	

1

```
// 从 x 搜索，搜索到其他的结点 
```

2

```
void dfs(int x,int ...){
```

3

```
     
```

4

```
    for(int k = 1 ; k <= n ; k ++){
```

5

```
        ...
```

6

```
            dfs(k);
```

7

```
    }
```

8

```
 }
```

9

```
 
```

10

```
dfs(结点)
```

##### 			广度优先搜索 `BFS`  	

1

```
 head .. tail 
```

2

```
 while(head <= tail){
```

3

```
     ...
```

4

```
      for(int k = 1 ; k <= n ; k ++){
```

5

```
            ...
```

6

```
                q[++tail] = k;
```

7

```
        }
```

8

```
 }
```

## 			图的练习  	

### 			A. 图的dfs遍历  	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 11;
```

4

```
int a[N][N], n, e;
```

5

```
//标记哪些结点搜索过，哪些没有搜索过
```

6

```
bool vis[N];
```

7

```
 
```

8

```
void dfs(int x) {
```

9

```
 vis[x] = 1;
```

10

```
 //打印访问到的结点
```

11

```
 cout << x << " ";
```

12

```
 // 从x开始，能搜到哪里
```

13

```
 /*
```

14

```
           x
```

15

```
        / | \ \...\
```

16

```
       1  ...     n
```

17

```
   ①  k这个结点没有被访问过
```

18

```
   ②  x -> k
```

19

```
 */
```

20

```
 for (int k = 1 ; k <= n ; k ++) {
```

21

```
  // k结点还没有搜索过
```

22

```
  if (!vis[k] && a[x][k]) {
```

23

```
   dfs(k);
```

24

```
  }
```

25

```
 }
```

26

```
}
```

27

```
 
```

28

```
int main() {
```

29

```
 cin >> n >> e;
```

30

```
 int x, y;
```

31

```
 for (int i = 1 ; i <= e ; i ++) {
```

32

```
  cin >> x >> y;
```

33

```
  //表示 x - y
```

34

```
  a[x][y] = a[y][x] = 1;
```

35

```
 }
```

36

```
 dfs(1);
```

37

```
 return 0;
```

38

```
}
```

#### 			B. 图的bfs遍历  	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 11;
```

4

```
int a[N][N], n, e;
```

5

```
//标记哪些结点搜索过，哪些没有搜索过
```

6

```
bool vis[N];
```

7

```
int q[N * N];
```

8

```
 
```

9

```
void bfs(int x) {
```

10

```
 int head = 1, tail = 0, hx;
```

11

```
 //第一个入队的结点
```

12

```
 q[++tail] = x;
```

13

```
 // 入队时输出
```

14

```
 cout << x << " ";
```

15

```
 vis[x] = 1;
```

16

```
 //如果队列中，存在元素的话
```

17

```
 while (head <= tail) {
```

18

```
  //头结点
```

19

```
  hx = q[head];
```

20

```
  /*      hx
```

21

```
        /|||\
```

22

```
    k: 1234..n
```

23

```
   */
```

24

```
  for (int k = 1 ; k <= n ; k ++) {
```

25

```
   if (!vis[k] && a[hx][k]) {
```

26

```
    q[++tail] = k;
```

27

```
    cout << k << " ";
```

28

```
    // 入队标记
```

29

```
    vis[k] = 1;
```

30

```
   }
```

31

```
  }
```

32

```
  head ++;
```

33

```
 }
```

34

```
}
```

35

```
 
```

36

```
int main() {
```

37

```
 cin >> n >> e;
```

38

```
 int x, y;
```

39

```
 for (int i = 1 ; i <= e ; i ++) {
```

40

```
  cin >> x >> y;
```

41

```
  //表示 x - y
```

42

```
  a[x][y] = a[y][x] = 1;
```

43

```
 }
```

44

```
 bfs(1);
```

45

```
 return 0;
```

46

```
}
```

#### 			C. 素数路径  	

- 看路线遍历的点最多是多少

  - 更适合深搜

    1

    ```
    // l 访问的层数 / 个数
    ```

    2

    ```
    void dfs(int x,int l){
    ```

    3

    ```
        ...
    ```

    4

    ```
          dfs(k,l + 1);
    ```

    5

    ```
    }
    ```

- 把所有的结点都走一遍

  - 回溯

  1

  ```
  // 所有路线都走一遍
  ```

  2

  ```
  void dfs(int x,int l){
  ```

  3

  ```
      vis[x] = 1;
  ```

  4

  ```
      ...
  ```

  5

  ```
        dfs(k,l + 1);
  ```

  6

  ```
      ... 
  ```

  7

  ```
      vis[x] = 0;
  ```

  8

  ```
  }
  ```

- 当前结点与下一个结点的数值之和为 素数 !

  - 判断素数

    1

    ```
    bool check(int x){
    ```

    2

    ```
        if(x < 2) return false;
    ```

    3

    ```
        //遍历可能的因子  2 ~ x的平方根
    ```

    4

    ```
        for(int i = 2 ; i <= sqrt(x) ; i ++){
    ```

    5

    ```
            if(x % i == 0) return false;
    ```

    6

    ```
        }
    ```

    7

    ```
        return true;
    ```

    8

    ```
    }
    ```

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 11;
```

4

```
int a[N][N], n, e, ma;
```

5

```
//标记哪些结点搜索过，哪些没有搜索过
```

6

```
bool vis[N];
```

7

```
 
```

8

```
bool check(int x) {
```

9

```
 if (x < 2) return false;
```

10

```
 for (int i = 2 ; i <= sqrt(x) ; i ++) {
```

11

```
  if (x % i == 0) return false;
```

12

```
 }
```

13

```
 return true;
```

14

```
}
```

15

```
 
```

16

```
void dfs(int x, int c) {
```

17

```
 //表示到达过了
```

18

```
 vis[x] = 1;
```

19

```
 ma = max(ma, c);
```

20

```
 //能搜索到哪些结点
```

21

```
 for (int i = 1 ; i <= n ; i ++) {
```

22

```
  if (!vis[i] && a[x][i] && check(x + i)) {
```

23

```
   //下一个点
```

24

```
   dfs(i, c + 1);
```

25

```
  }
```

26

```
 }
```

27

```
 //回溯
```

28

```
 vis[x] = 0;
```

29

```
}
```

30

```
 
```

31

```
int main() {
```

32

```
 cin >> n >> e;
```

33

```
 int x, y, s;
```

34

```
 for (int i = 1 ; i <= e ; i ++) {
```

35

```
  cin >> x >> y;
```

36

```
  //表示 x - y
```

37

```
  a[x][y] = a[y][x] = 1;
```

38

```
 }
```

39

```
 //起点城市
```

40

```
 cin >> s;
```

41

```
 //从起点城市出发
```

42

```
 dfs(s, 1);
```

43

```
 /*
```

44

```
   无法访问任何满足题意的城市，请输出 0
```

45

```
 */
```

46

```
 if (ma == 1) cout << 0;
```

47

```
 else cout << ma;
```

48

```
 return 0;
```

49

```
}
```

#### 			D. 快速访问  	

- 记录到达每一个节点的最少步数