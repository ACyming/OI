# 	**2023.11.3 邻接表**  	

## 			基本结构  	

- 图的记录方式

- 思路：记录边

  - 把每一条边都存入数组。

    1

    ```
    struct Edge{
    ```

    2

    ```
      int st;   // 起点，一般情况下可以不写
    ```

    3

    ```
        int ed;   // 终点，
    ```

    4

    ```
        int next; // 同起点的上一条边
    ```

    5

    ```
     int len;  // 表示边长 
    ```

    6

    ```
    };
    ```

    7

    ```
    // 使用结构体类型定义一个边的记录数组
    ```

    8

    ```
    Edge e[M];
    ```

    9

    ```
    int c;
    ```

    10

    ```
     
    ```

    11

    ```
    第 i 条边： e[i]
    ```

    12

    ```
         e[i].len
    ```

    13

    ```
       * ------ *
    ```

    14

    ```
       ↑        ↑
    ```

    15

    ```
    e[i].st   e[i].ed               
    ```

  - 如果对边排序，那么在结点搜索时，可以优先结点从大到小或者从小到大。

  - 如果结点的访问顺序，无所谓结点数值优先，那么可以不排序。

  - 边的依次连接，取决于结点之间的连接

    - 同一条边上

      1

      ```
         * ----- *
      ```

    - 不在同一条边

      1

      ```
          *
      ```

      2

      ```
            \
      ```

      3

      ```
             *
      ```

      4

      ```
              \
      ```

      5

      ```
                *       
      ```

  - 每一条边的同起点上一条边

    1

    ```
             * 
    ```

    2

    ```
        /  |  |  \ 
    ```

    3

    ```
       ①   ②  ③   ④ 
    ```

    4

    ```
     /     |  |    \
    ```

    5

    ```
       e[①].next => 0   
    ```

    6

    ```
       e[②].next => ①           
    ```

    7

    ```
       e[③].next => ②          
    ```

    8

    ```
       e[④].next => ③
    ```

    9

    ```
    我们可以通过某一个结点开始的最后一条（比如：④），往前追溯该起点开始的所有边。
    ```

  - 那么谁来记录，某一个结点的最后一条边的编号呢？

    - `int head[N]`

      1

      ```
              * - 100 
      ```

      2

      ```
          /  |  |  \ 
      ```

      3

      ```
         ①   ②  ③   ④ 
      ```

      4

      ```
       /     |  |    \
      ```

      5

      ```
                  
      ```

      6

      ```
       head[100] = ④           
      ```

- 循环遍历

  - 从搜索的起点出发

    1

    ```
             *  x  ← 搜索起点
    ```

    2

    ```
          / | \ \
    ```

    3

    ```
                 y
    ```

    4

    ```
                 
    ```

    5

    ```
    先求出以 x 作为起点的最后一条边的编号 i 
    ```

    6

    ```
        x → y
    ```

    7

    ```
                 
    ```

    8

    ```
       for(i = head[x] ; i > 0 ; i = e[i].next){
    ```

    9

    ```
           int y = e[i].ed;  // ed 终点 
    ```

    10

    ```
           // dfs(y)      q.push(y)
    ```

    11

    ```
       }          
    ```

## 			建图  	

- 无向图
  - 双向建边 （边的数组需要两倍的长度）

#### 			C. 素数路径  	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int M = 46, N = 11;
```

4

```
struct Edge {
```

5

```
 int st, ed, next;
```

6

```
} e[M * 2];
```

7

```
// 记录每一个结点的最后一条边
```

8

```
int head[N], n, m, s, c, ans; // c:总边数
```

9

```
 
```

10

```
bool check(int x) {
```

11

```
 if (x < 2) return false;
```

12

```
 for (int i = 2 ; i <= sqrt(x) ; i ++) {
```

13

```
  if (x % i == 0) return false;
```

14

```
 }
```

15

```
 return true;
```

16

```
}
```

17

```
 
```

18

```
void add(int u, int v) {
```

19

```
 /*
```

20

```
 c ++;
```

21

```
 e[c].st = u;
```

22

```
 e[c].ed = v;
```

23

```
 e[c].next = head[u];
```

24

```
 */
```

25

```
 e[++c] = {u, v, head[u]};
```

26

```
 head[u] = c;
```

27

```
}
```

28

```
// x:到达城市 cnt:经过的城市数
```

29

```
bool vis[N];
```

30

```
void dfs(int x, int cnt) {
```

31

```
 vis[x] = 1;
```

32

```
 ans = max(ans, cnt);
```

33

```
 for (int i = head[x] ; i > 0 ; i = e[i].next) {
```

34

```
  int to = e[i].ed;
```

35

```
  if (!vis[to] && check(x + to)) {
```

36

```
   dfs(to, cnt + 1);
```

37

```
  }
```

38

```
 }
```

39

```
 vis[x] = 0;
```

40

```
}
```

41

```
 
```

42

```
int main() {
```

43

```
 cin >> n >> m;
```

44

```
 int u, v;
```

45

```
 for (int i = 1 ; i <= m ; i ++) {
```

46

```
  cin >> u >> v;
```

47

```
  add(u, v);
```

48

```
  add(v, u);
```

49

```
 }
```

50

```
 cin >> s;
```

51

```
 dfs(s, 1);
```

52

```
 if (ans == 1) cout << 0;
```

53

```
 else cout << ans;
```

54

```
 return 0;
```

55

```
}
```

# 			SPFA 最短路  	

- 思路

  - 计算起点出发到达每一个结点的最少距离

    - 初始状态，认为起点到达其他每一个节点的距离都是最大数值（不可到达）

      1

      ```
      for(int i = 1 ; i <= n ; i ++){
      ```

      2

      ```
          dis[i] = 0x3f3f3f3f;           // 0x3f3f3f3f 极大值
      ```

      3

      ```
      }
      ```

  - 广搜实现

    - 建议用 `queue<int>` 队列对象取实现！

      - 先进先出

      1

      ```
      queue<int> q;
      ```

      - 入队

        1

        ```
        q.push(x);
        ```

        2

        ```
         
        ```

        3

        ```
        [                ]  
        ```

        4

        ```
                       ↑
        ```

        5

        ```
                      q.push(x)                
        ```

      - 出队

        1

        ```
        q.pop();
        ```

        2

        ```
         
        ```

        3

        ```
        [                 ]
        ```

        4

        ```
          ↑
        ```

        5

        ```
         q.pop()
        ```

        6

        ```
              
        ```

        7

        ```
            [             ]
        ```

      - 获取队头元素

        1

        ```
        int hx = q.front();
        ```

      - 判断队列是否为空

        - `q.size() > 0` 说明队列不为空
        - `!q.empty()` 说明队列不为空

  - 朴素广搜求解

    - 结点可能多次进入队列，造成空间的浪费。

      1

      ```
      比如： n 个节点 ，即使所有的 n 个结点，都加入队列.
      ```

      2

      ```
          q[N * 2];
      ```

      3

      ```
       queue<int>  也可能造成空间的不够，queue也有空间的上限。
      ```

    - 所以 SPFA ，有数组标记每一个结点是不是存在于队列中。

      - `in[k] 表示 k 是否在队列中`

      - 只有 `in[k] 为false`时，才能够将 k 结点加入队列。

      - 无论 k 是不是要加入队列，如果符合收缩条件，那么起点到 k 的最短距离一定会被收缩。

        1

        ```
                   hx     dis[hx] + (hx->k) < dis[k]  距离被收缩 !!!
        ```

        2

        ```
                 /   \              (三角不等式)
        ```

        3

        ```
        s .............k
        ```

        4

        ```
                      -> dis[k]
        ```

- `in[k]` 表示 k 这个结点是否已经存在于队列中。

  - 入队

    1

    ```
     ......
    ```

    2

    ```
          if(!in[k]){
    ```

    3

    ```
              q.push(k);
    ```

    4

    ```
              // 说明 k 已经在队列中
    ```

    5

    ```
              in[k] = true;
    ```

    6

    ```
          }
    ```

  - 出队

    1

    ```
    .....
    ```

    2

    ```
        while(q.size() > 0){  // !q.empty()
    ```

    3

    ```
            int hx= q.front();
    ```

    4

    ```
            q.pop();
    ```

    5

    ```
            int[k] = false;
    ```

    6

    ```
            .....
    ```

    7

    ```
                
    ```

    8

    ```
        }
    ```

#### 			A. 有负权边的最短路  	

1

```
#include <bits/stdc++.h>
```

2

```
#define inf 0x3f3f3f3f
```

3

```
using namespace std;
```

4

```
const int M = 2e5 + 10, N = 2e4 + 10;
```

5

```
struct Edge {
```

6

```
 int ed, next, len;
```

7

```
} e[M];
```

8

```
int head[N], c, n, m, dis[N];
```

9

```
 
```

10

```
void add(int u, int v, int l) {
```

11

```
 e[++c] = {v, head[u], l};
```

12

```
 head[u] = c;
```

13

```
}
```

14

```
 
```

15

```
/*
```

16

```
 SPFA 广搜
```

17

```
*/
```

18

```
queue<int> q;
```

19

```
int in[N];
```

20

```
 
```

21

```
void bfs(int s) {
```

22

```
 // 起点到达自己的距离为0
```

23

```
 dis[s] = 0;
```

24

```
 q.push(s);
```

25

```
 in[s] = true;
```

26

```
 // 只要队列不为空
```

27

```
 while (q.size() > 0) {
```

28

```
  // 即将出队的结点
```

29

```
  int hx = q.front();
```

30

```
  q.pop();
```

31

```
  in[hx] = false;
```

32

```
  // 看下一个访问结点
```

33

```
  for (int i = head[hx] ; i > 0 ; i = e[i].next) {
```

34

```
   int to = e[i].ed;
```

35

```
   // 距离更短
```

36

```
   if (dis[hx] + e[i].len < dis[to]) {
```

37

```
    // 距离收缩
```

38

```
    dis[to] = dis[hx] + e[i].len;
```

39

```
    // 现在 to 这个结点是否在队列之中
```

40

```
    if (!in[to]) {
```

41

```
     q.push(to);
```

42

```
     in[to] = true;
```

43

```
    }
```

44

```
   }
```

45

```
  }
```

46

```
 }
```

47

```
}
```

48

```
 
```

49

```
int main() {
```

50

```
 cin >> n >> m;
```

51

```
 int i, u, v, l;
```

52

```
 for (i = 1 ; i <= m ; i ++) {
```

53

```
  cin >> u >> v >> l;
```

54

```
  add(u, v, l);
```

55

```
 }
```

56

```
 for (i = 1 ; i <= n ; i ++) {
```

57

```
  dis[i] = inf;
```

58

```
 }
```

59

```
 bfs(1);
```

60

```
 // 输出起点到达每一个结点的最少距离
```

61

```
 for (i = 2 ; i <= n ; i ++) {
```

62

```
  cout << dis[i] << endl;
```

63

```
 }
```

64

```
 return 0;
```

65

```
}
```

  