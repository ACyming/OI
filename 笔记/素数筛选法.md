# 	**2023.11.10 SPFA求解最短距离** 	

## 			B. 香甜的黄油(Sweet Butter) 	

![image-20231117184642171](http://0519os.comc/Users/wsjsz/AppData/Roaming/Typora/typora-user-images/image-20231117184642171.png)

1

```
距离和最短
```

2

```
    某一个结点到达每一个存在奶牛的牧场的路程之和，最少。
```

3

```
    
```

4

```
思路：（每一头牛到达位置 等同于 这个位置到达每一头牛）
```

5

```
   1、建图 (邻接表)
```

6

```
   建边，将每一条边存入数组！
```

7

```
   2、枚举每一个可能的牧场，作为搜索的起点 i
```

8

```
   3、从起点 i 出发，计算到达每一个有牛存在的牧场的最短距离之和
```

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
 
```

4

```
const int P = 810;//点
```

5

```
const int C = 1460;//边
```

6

```
 
```

7

```
struct node {
```

8

```
 int to, next, len;
```

9

```
} e[C * 2]; // 存储所有边的数组
```

10

```
int pre[P], k; // k:记录边的条数  pre[P]记录每一个结点的最后一条边的编号
```

11

```
int d[P];
```

12

```
bool f[P];
```

13

```
 
```

14

```
int a[510];//哪些点有奶牛
```

15

```
int n, p, c;
```

16

```
queue<int> q;//队列
```

17

```
 
```

18

```
void add(int u, int v, int len) {
```

19

```
 k++;
```

20

```
 e[k].to = v;
```

21

```
 e[k].len = len;
```

22

```
 e[k].next = pre[u];
```

23

```
 pre[u] = k;
```

24

```
}
```

25

```
 
```

26

```
//求从s号牧场出发到每个奶牛位置最短路的和
```

27

```
int spfa(int s) {
```

28

```
 // d数组表示从起点s出发，到达每一个其他结点位置的最小距离
```

29

```
 memset(d, 0x3f, sizeof(d));
```

30

```
 // f数组标记该结点是否存在于队列之中
```

31

```
 memset(f, 0, sizeof(f));
```

32

```
 d[s] = 0;
```

33

```
 q.push(s);
```

34

```
 f[s] = true;
```

35

```
 // q表示 广搜的队列模型
```

36

```
 while (!q.empty()) {
```

37

```
  // 队头元素
```

38

```
  int h = q.front();
```

39

```
  q.pop();
```

40

```
  // 出队反标记
```

41

```
  f[h] = false;
```

42

```
  //判断从q出发能去哪些点
```

43

```
  for (int i = pre[h]; i != 0; i = e[i].next) {
```

44

```
   // 每一条边，所到达的一段
```

45

```
   int to = e[i].to;
```

46

```
   // 如果距离更优
```

47

```
   if (d[h] + e[i].len < d[to]) {
```

48

```
    d[to] = d[h] + e[i].len;
```

49

```
    if (!f[to]) {
```

50

```
     q.push(to);
```

51

```
     f[to] = true;
```

52

```
    }
```

53

```
   }
```

54

```
  }
```

55

```
 }
```

56

```
 //求从s出发到每个奶牛所在位置的最短的和
```

57

```
 int sum = 0;
```

58

```
 for (int i = 1; i <= n; i++) {
```

59

```
  if (d[a[i]] == 0x3f3f3f3f) return 0x3f3f3f3f;
```

60

```
  else sum += d[a[i]];
```

61

```
 }
```

62

```
 return sum;
```

63

```
}
```

64

```
 
```

65

```
int main() {
```

66

```
 // n:奶牛个数 p:牧场的个数 c:牧场之间的关系条数
```

67

```
 cin >> n >> p >> c;
```

68

```
 //n头奶牛的位置
```

69

```
 for (int i = 1; i <= n; i++) {
```

70

```
  cin >> a[i];
```

71

```
 }
```

72

```
 int x, y, len;
```

73

```
 for (int i = 1; i <= c; i++) {
```

74

```
  cin >> x >> y >> len;
```

75

```
  // 双向加边
```

76

```
  add(x, y, len);
```

77

```
  add(y, x, len);
```

78

```
 }
```

79

```
 
```

80

```
 //从p个牧场的每个位置开始spfa
```

81

```
 int ans = 0x3f3f3f3f;
```

82

```
 for (int i = 1; i <= p; i++) {
```

83

```
  ans = min(ans, spfa(i));
```

84

```
 }
```

85

```
 cout << ans;
```

86

```
 return 0;
```

87

```
}
```

#### 			C. 最少的手续费 	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
 
```

4

```
int a[2010][2010];//邻接矩阵
```

5

```
int n, m, s, e; //s,e表示起止点start，end.
```

6

```
//反推要使得B得到100元，那么每个点至少要汇出多少钱
```

7

```
double d[2010];
```

8

```
bool f[2010];
```

9

```
queue<int> q;
```

10

```
 
```

11

```
void spfa(int s) {
```

12

```
 f[s] = 1;
```

13

```
 q.push(s);
```

14

```
 d[s] = 100;
```

15

```
 int hx;
```

16

```
 while (q.size() > 0) {
```

17

```
  hx = q.front();
```

18

```
  q.pop();
```

19

```
  f[hx] = false;
```

20

```
  for (int k = 1 ; k <= n ; k ++) {
```

21

```
   /*
```

22

```
       hx  →  k
```

23

```
          d[k] =  d[hx] / (1 - a[hx][k] * 0.01); 
```

24

```
    */
```

25

```
   if (a[hx][k] > 0 && d[hx] / (1 - a[hx][k] * 0.01) < d[k]) {
```

26

```
    d[k] = d[hx] / (1 - a[hx][k] * 0.01);
```

27

```
    if (!f[k]) {
```

28

```
     q.push(k);
```

29

```
     f[k] = 1;
```

30

```
    }
```

31

```
   }
```

32

```
  }
```

33

```
 }
```

34

```
}
```

35

```
 
```

36

```
int main() {
```

37

```
 cin >> n >> m;
```

38

```
 int x, y, z;
```

39

```
 for (int i = 1; i <= m; i++) {
```

40

```
  cin >> x >> y >> z;
```

41

```
  a[x][y] = z;
```

42

```
  a[y][x] = z;
```

43

```
 }
```

44

```
 cin >> s >> e;
```

45

```
 for (int i = 1; i <= n; i++) d[i] = 0x3f3f3f3f;
```

46

```
 spfa(e);
```

47

```
 cout << fixed << setprecision(8) << d[s];
```

48

```
 return 0;
```

49

```
 
```

50

```
}
```

#### 			D. 电器快递 	

- 反向建边，有向图

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
 
```

4

```
const int N = 1e3 + 10, M = 1e5 + 10;
```

5

```
 
```

6

```
struct node {
```

7

```
 int to, len, next;
```

8

```
} zheng[M], fan[M];
```

9

```
/*
```

10

```
  zheng[]:正向建边
```

11

```
  fan[]:反向建边
```

12

```
 */
```

13

```
int pre1[N], pre2[N];
```

14

```
int k1, k2; //正、反建边的边数
```

15

```
/*
```

16

```
  pre1[]:zheng数组的
```

17

```
  pre2[]:fan数组的
```

18

```
 */
```

19

```
int dis1[N];//1点到每个点的最短路
```

20

```
int dis2[N];//每个点到1点的最短路
```

21

```
bool f1[N];//求1点到每个点的最短路时使用
```

22

```
bool f2[N];//求每个点到1点的最短路时使用
```

23

```
 
```

24

```
void zheng_add(int u, int v, int len) { //正向建边
```

25

```
 zheng[++k1] = {v, len, pre1[u]};
```

26

```
 pre1[u] = k1;
```

27

```
}
```

28

```
 
```

29

```
void fan_add(int u, int v, int len) { //反向建边
```

30

```
 fan[++k2] = {v, len, pre2[u]};
```

31

```
 pre2[u] = k2;
```

32

```
}
```

33

```
 
```

34

```
int main() {
```

35

```
 int n, m, x, y, t;
```

36

```
 cin >> n >> m;
```

37

```
 for (int i = 1; i <= m; i++) {
```

38

```
  cin >> x >> y >> t;
```

39

```
  zheng_add(x, y, t);
```

40

```
  fan_add(y, x, t);
```

41

```
 }
```

42

```
 // 队列
```

43

```
 queue<int> q;
```

44

```
 // 最短路的数组记录
```

45

```
 memset(dis1, 0x3f, sizeof(dis1)); //1点到每个点的最短路
```

46

```
 dis1[1] = 0;
```

47

```
 q.push(1);
```

48

```
 f1[1] = true;
```

49

```
 // 只要队列中存在元素
```

50

```
 while (!q.empty()) {
```

51

```
  int h = q.front();
```

52

```
  q.pop();
```

53

```
  f1[h] = false;
```

54

```
  // 以 h 作为上一个结点，取搜索下一个结点。
```

55

```
  for (int i = pre1[h]; i; i = zheng[i].next) {
```

56

```
   int to = zheng[i].to;
```

57

```
   if (dis1[h] + zheng[i].len < dis1[to]) {
```

58

```
    dis1[to] = dis1[h] + zheng[i].len;
```

59

```
    if (!f1[to]) {
```

60

```
     f1[to] = true;
```

61

```
     q.push(to);
```

62

```
    }
```

63

```
   }
```

64

```
  }
```

65

```
 }
```

66

```
 memset(dis2, 0x3f, sizeof(dis2)); //每个点到1点的最短路
```

67

```
 while (!q.empty()) q.pop(); //清空队列
```

68

```
 dis2[1] = 0;
```

69

```
 f2[1] = true;
```

70

```
 q.push(1);
```

71

```
 while (!q.empty()) {
```

72

```
  int h = q.front();
```

73

```
  q.pop();
```

74

```
  f2[h] = false;
```

75

```
  for (int i = pre2[h]; i; i = fan[i].next) {
```

76

```
   int to = fan[i].to;
```

77

```
   if (dis2[h] + fan[i].len < dis2[to]) {
```

78

```
    dis2[to] = dis2[h] + fan[i].len;
```

79

```
    if (!f2[to]) {
```

80

```
     f2[to] = true;
```

81

```
     q.push(to);
```

82

```
    }
```

83

```
   }
```

84

```
  }
```

85

```
 }
```

86

```
 int ans = 0;
```

87

```
 for (int i = 2; i <= n; i++) {
```

88

```
  ans += (dis1[i] + dis2[i]);
```

89

```
 }
```

90

```
 cout << ans << endl;
```

91

```
 return 0;
```

92

```
}
```

# 			**2023.11.17 素数筛选法** 	

## 			素数判断 	

- 因子枚举

1

```
bool isPrime(int x){
```

2

```
    if(x < 2) return false;
```

3

```
    // 循环遍历，可能的因子（约数）
```

4

```
    for(int i = 2 ; i <= sqrt(x) ; i ++){
```

5

```
        // 如果存在因子满足倍数关系，那么一定不是素数
```

6

```
        if(x % i == 0){
```

7

```
   return false;            
```

8

```
        }
```

9

```
    }
```

10

```
    return true;
```

11

```
}
```

## 			埃式筛选法 （埃筛） 	

- 思路

  - 假设所有的数都是素数

    1

    ```
    bool Not[N];  //标记非素数  
    ```

  - 0 1

    一定不是素数

    

    1

    ```
    Not[0] = 1;  // 标记为 非素数
    ```

    2

    ```
    Not[1] = 1;
    ```

  - 2

    这个数字一定是已知的素数

    

  - 从2

    开始，往后遍历，只要是素数，那么就标记倍数。

    

    - 素数装填

      1

      ```
      int Primes[N],c;
      ```

    - 把素数的倍数标记为 `非素数`

    1

    ```
    // n范围内的素数
    ```

    2

    ```
    for(i = 2 ; i <= n ; i ++){
    ```

    3

    ```
        // i是素数
    ```

    4

    ```
        if(!Not[i]){
    ```

    5

    ```
            // 把 i 这个素数，装入数组 Primes 中。
    ```

    6

    ```
            Primes[++c] = i;
    ```

    7

    ```
            // 标记 i 的倍数
    ```

    8

    ```
            for(j = i * 2 ; j <= n ; j += i){
    ```

    9

    ```
                Not[j] = 1;
    ```

    10

    ```
            }
    ```

    11

    ```
        }
    ```

    12

    ```
    }
    ```

  ### 					**1942 - 回文质数 Prime Palindromes** 			

  - 超时

  1

  ```
  #include <bits/stdc++.h>
  ```

  2

  ```
  using namespace std;
  ```

  3

  ```
  const int N = 1e8 + 10;
  ```

  4

  ```
  bool Not[N]; // 标记非素数
  ```

  5

  ```
  int Primes[N], c, a, b;
  ```

  6

  ```
   
  ```

  7

  ```
  void Es() {
  ```

  8

  ```
   Not[0] = Not[1] = true;
  ```

  9

  ```
   int i, j;
  ```

  10

  ```
   for (i = 2 ; i <= b ; i ++) {
  ```

  11

  ```
    if (!Not[i]) {
  ```

  12

  ```
     Primes[++c] = i;
  ```

  13

  ```
     // 倍数标记
  ```

  14

  ```
     for (j = i * 2 ; j <= b ; j += i) {
  ```

  15

  ```
      Not[j] = true;
  ```

  16

  ```
     }
  ```

  17

  ```
    }
  ```

  18

  ```
   }
  ```

  19

  ```
  }
  ```

  20

  ```
   
  ```

  21

  ```
  bool check(int x) {
  ```

  22

  ```
   // 短除法
  ```

  23

  ```
   int y = 0, t = x;
  ```

  24

  ```
   while (t > 0) {
  ```

  25

  ```
    // 反向拼接
  ```

  26

  ```
    y = y * 10 + t % 10;
  ```

  27

  ```
    t /= 10;
  ```

  28

  ```
   }
  ```

  29

  ```
   return x == y;
  ```

  30

  ```
  }
  ```

  31

  ```
   
  ```

  32

  ```
  int main() {
  ```

  33

  ```
   cin >> a >> b;
  ```

  34

  ```
   Es();
  ```

  35

  ```
   for (int i = 1 ; i <= c; i ++) {
  ```

  36

  ```
    if (Primes[i] >= a && Primes[i] <= b && check(Primes[i])) {
  ```

  37

  ```
     //cout << Primes[i] << endl;
  ```

  38

  ```
     printf("%d\n",Primes[i]);
  ```

  39

  ```
    }
  ```

  40

  ```
   }
  ```

  41

  ```
   return 0;
  ```

  42

  ```
  }
  ```

## 			欧拉筛选 	

- 防止重复标记

  - 每一个数只能被一天个数值所标记

- 代码实现

  1

  ```
  bool Not[N];  // 非素数标记
  ```

  2

  ```
  int Primes[N],c;
  ```

  3

  ```
   
  ```

  4

  ```
  void Os(){
  ```

  5

  ```
      Not[0] = Not[1] = 1;
  ```

  6

  ```
      /*
  ```

  7

  ```
      ① 判定数
  ```

  8

  ```
      ② 素数倍数
  ```

  9

  ```
      */
  ```

  10

  ```
      for(int i = 2 ; i <= n ; i ++){
  ```

  11

  ```
          if(!Not[i]){
  ```

  12

  ```
              Primes[++c] = i;
  ```

  13

  ```
          }
  ```

  14

  ```
          // 无论是否是素数，都要标记 * i
  ```

  15

  ```
          for(int j = 1 ; j <= c  && Primes[j] * i <= n ; j ++){
  ```

  16

  ```
     // 欧拉筛选法中，标记对象 : Primes[j] * i
  ```

  17

  ```
              Not[Primes[j] * i] = 1;
  ```

  18

  ```
              // 
  ```

  19

  ```
              if(i % Primes[j] == 0) break;
  ```

  20

  ```
          }
  ```

  21

  ```
      }
  ```

  22

  ```
  }
  ```

### 			**1942 - 回文质数 Prime Palindromes** 	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 1e8 + 10;
```

4

```
bool Not[N]; // 标记非素数
```

5

```
int Primes[N], c, a, b;
```

6

```
 
```

7

```
void Es() {
```

8

```
 Not[0] = Not[1] = true;
```

9

```
 int i, j;
```

10

```
 for (i = 2 ; i <= b ; i ++) {
```

11

```
  if (!Not[i]) {
```

12

```
   Primes[++c] = i;
```

13

```
   // 倍数标记
```

14

```
   for (j = i * 2 ; j <= b ; j += i) {
```

15

```
    Not[j] = true;
```

16

```
   }
```

17

```
  }
```

18

```
 }
```

19

```
}
```

20

```
 
```

21

```
void Os() {
```

22

```
 Not[0] = Not[1] = true;
```

23

```
 int i, j;
```

24

```
 for (i = 2 ; i <= b ; i ++) {
```

25

```
  if (!Not[i]) {
```

26

```
   Primes[++c] = i;
```

27

```
  }
```

28

```
  // 倍数标记
```

29

```
  for (j = 1 ; j <= c && Primes[j] * i <= b; j ++) {
```

30

```
   Not[Primes[j] * i] = true;
```

31

```
 
```

32

```
   if (i % Primes[j] == 0) break;
```

33

```
  }
```

34

```
 }
```

35

```
}
```

36

```
 
```

37

```
bool check(int x) {
```

38

```
 // 短除法
```

39

```
 int y = 0, t = x;
```

40

```
 while (t > 0) {
```

41

```
  // 反向拼接
```

42

```
  y = y * 10 + t % 10;
```

43

```
  t /= 10;
```

44

```
 }
```

45

```
 return x == y;
```

46

```
}
```

47

```
 
```

48

```
int main() {
```

49

```
 cin >> a >> b;
```

50

```
 Os();
```

51

```
 for (int i = 1 ; i <= c; i ++) {
```

52

```
  if (Primes[i] >= a && Primes[i] <= b && check(Primes[i])) {
```

53

```
   //cout << Primes[i] << endl;
```

54

```
   printf("%d\n", Primes[i]);
```

55

```
  }
```

56

```
 }
```

57

```
 return 0;
```

58

```
}
```

 

 