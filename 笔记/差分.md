# 	前缀和  	

- 数值区间求和

#### 			B. 相加之和最大，并给出它们的起始位置  	

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 50;
```

4

```
int a[N], b[N];
```

5

```
int main() {
```

6

```
 int n, i;
```

7

```
 cin >> n;
```

8

```
 for (i = 1 ; i <= n ; i ++) {
```

9

```
  cin >> a[i];
```

10

```
 }
```

11

```
 for (i = n + 1 ; i <= n * 2 ; i ++) {
```

12

```
  a[i] = a[i - n];
```

13

```
 }
```

14

```
 for (i = 1 ; i <= 2 * n ; i ++) {
```

15

```
  b[i] = b[i - 1] + a[i];
```

16

```
 }
```

17

```
 /*
```

18

```
      区间
```

19

```
      l  r
```

20

```
  */
```

21

```
 int ma = 0, p = -1;
```

22

```
 for (i = 1 ; i <= n ; i ++) {
```

23

```
  int l = i;
```

24

```
  int r = i + 3;
```

25

```
  if (b[r] - b[l - 1] > ma) {
```

26

```
   ma = b[r] - b[l - 1];
```

27

```
   p = i;
```

28

```
  }
```

29

```
 }
```

30

```
 cout << ma << endl << p;
```

31

```
 return 0;
```

32

```
}
```

#### 			D. 数学测试  	

1

```
#include <bits/stdc++.h>
```

2

```
#define ll long long
```

3

```
using namespace std;
```

4

```
 
```

5

```
const int N = 1e5 + 100;
```

6

```
ll  a[N],  b[N],  c[N];
```

7

```
//  原始数据  前缀和1 前缀和2
```

8

```
int main() {
```

9

```
 int n, i;
```

10

```
 cin >> n;
```

11

```
 for (i = 1; i <= n ; i ++) {
```

12

```
  scanf("%lld", &a[i]);
```

13

```
  // b[i]记录  1 ~ i 位置的数值之和
```

14

```
  b[i] = b[i - 1] + a[i];
```

15

```
 }
```

16

```
 sort(a + 1, a + 1 + n);
```

17

```
 for (i = 1 ; i <= n ; i ++) {
```

18

```
  c[i] = c[i - 1] + a[i];
```

19

```
 }
```

20

```
 int q, p, l, r;
```

21

```
 cin >> q;
```

22

```
 //询问 q 次，q次的循环遍历
```

23

```
 for (i = 1 ; i <= q ; i ++) {
```

24

```
  //cin >> p >> l >> r;
```

25

```
  scanf("%d%d%d", &p, &l, &r);
```

26

```
  if (p == 1) {
```

27

```
   //cout << b[r] - b[l - 1] << endl;
```

28

```
   printf("%lld\n", b[r] - b[l - 1]);
```

29

```
  } else {
```

30

```
   //cout << c[r] - c[l - 1] << endl;
```

31

```
   printf("%lld\n", c[r] - c[l - 1]);
```

32

```
  }
```

33

```
 }
```

34

```
 return 0;
```

35

```
}
```

#### 			G. 字母项链（necklace）  	

- 思路

1

```
   W J O I
```

2

```
=> W J O I
```

3

```
=> J O I W    
```

4

```
=> O I W J
```

5

```
=> I W J O      
```

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
 
```

4

```
string s;
```

5

```
long long a[200010], x, ma = 0, b[200010];
```

6

```
 
```

7

```
int main() {
```

8

```
 //字符串读入
```

9

```
 cin >> s;
```

10

```
 int n = s.size();
```

11

```
 for (int i = 0; i < n; i++) {
```

12

```
  a[i + 1] = (s[i] - 'A' + 1);
```

13

```
  a[i + 1 + n] = a[i + 1];
```

14

```
 }
```

15

```
 /*  i下标字符，对应的整数记录在 i+1的位置上
```

16

```
      s:   W  J   O  I   W   J   O
```

17

```
           0  1   2  3   4   5   6       
```

18

```
   
```

19

```
      a: 23  10  15  9  23  10  15  
```

20

```
          1   2   3  4   5   6   7
```

21

```
   
```

22

```
  */
```

23

```
 
```

24

```
 /*
```

25

```
   a: 23  10  15  9  23  10  15   0
```

26

```
 
```

27

```
   b: 23  33  48 57  80  90  105  105
```

28

```
      
```

29

```
      1   2   3  4   5   6   7
```

30

```
      ------------
```

31

```
  */
```

32

```
 for (int i = 1; i <= n * 2; i++) {
```

33

```
  b[i] = a[i] + b[i - 1];
```

34

```
 }
```

35

```
 
```

36

```
 for (int i = 1; i <= n; i++) {
```

37

```
  x += a[i] * i;
```

38

```
 }
```

39

```
 /*
```

40

```
      W J O I  =>  124
```

41

```
      1 2 3 4
```

42

```
        ----
```

43

```
     W*1 + J*2 + O*3 + I*4 
```

44

```
            ↓     ↓     ↓
```

45

```
           J*1 + O*2  + I*3  + W*4
```

46

```
   
```

47

```
   n:4              (n - 1) * a[i - 1]
```

48

```
                                W
```

49

```
    i-1   i  i+1  i+2 
```

50

```
          ----n-1----
```

51

```
                   ↑
```

52

```
                 i+n-2
```

53

```
   
```

54

```
     b[r] - b[l-1]
```

55

```
  */
```

56

```
 ma = x;
```

57

```
 for (int i = 2; i <= n; i++) {
```

58

```
  // (b[i + n - 1] - b[i - 1])
```

59

```
  x = x - (b[i + n - 2] - b[i - 1]) + (n - 1) * a[i - 1];
```

60

```
  ma = max(ma, x);
```

61

```
 }
```

62

```
 cout << ma;
```

63

```
 return 0;
```

64

```
}
```

#### 			B. 最大纯色正方形  	

- 猜正方形的长度
- 左上角的坐标

1

```
  //枚举  正方形边长
```

2

```
  for(l = 1 ; l <= min(n,m) ; l ++){
```

3

```
      for(i = 1 ; i <= n - l + 1 ; i ++){
```

4

```
          for(j = 1 ; j <= m - l + 1 ; j ++){
```

5

```
              
```

6

```
          }
```

7

```
      }
```

8

```
 }
```

- 二维数组前缀和

  1

  ```
    FOR ..
  ```

  2

  ```
        FOR ..
  ```

  3

  ```
            FOR ..
  ```

  4

  ```
                 //(i,j) 左上角  l 边长
  ```

  5

  ```
                   __
  ```

  6

  ```
                  |
  ```

  7

  ```
        
  ```

  8

  ```
        
  ```

  9

  ```
                              _|
  ```

  10

  ```
                //(i + l - 1,j + l - 1) 
  ```

1

```
#include <bits/stdc++.h>
```

2

```
using namespace std;
```

3

```
const int N = 2e2 + 10;
```

4

```
int n, m, a[N][N], b[N][N];
```

5

```
// 计算 左上角 到 右下角的数值之和
```

6

```
int query(int x1, int y1, int x2, int y2) {
```

7

```
 return b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1];
```

8

```
}
```

9

```
 
```

10

```
int main() {
```

11

```
 cin >> n >> m;
```

12

```
 int i, j;
```

13

```
 for (i = 1 ; i <= n ; i ++) {
```

14

```
  for (j = 1 ; j <= m ; j ++) {
```

15

```
   cin >> a[i][j];
```

16

```
   // 记录 1,1 位置到达每一个位置的数值之和 
```

17

```
   b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + a[i][j];
```

18

```
  }
```

19

```
 }
```

20

```
 int L, sum, ma = 0;
```

21

```
 // 枚举正方形的边长
```

22

```
 for (L = 1 ; L <= min(n, m); L ++) {
```

23

```
  // 起点坐标 (i,j)
```

24

```
  for (i = 1 ; i <= n - L + 1 ; i ++) {
```

25

```
   for (j = 1 ; j <= m - L + 1 ; j ++) {
```

26

```
    // (i,j) -> (i + L - 1,j + L - 1)
```

27

```
    sum = query(i, j, i + L - 1, j + L - 1);
```

28

```
    //cout<<sum<< "  (" << i << "," << j << ")" << "   " << "(" << i + L - 1 << "," << j + L - 1 << ")" << endl;
```

29

```
    if (sum == 0 || sum == L * L) {
```

30

```
     ma = max(ma, L * L);
```

31

```
    }
```

32

```
   }
```

33

```
  }
```

34

```
 }
```

35

```
 cout << ma;
```

36

```
 return 0;
```

37

```
}
```

# 			差分  	

## 			一维差分  	

- 区间数值修改

  - `L ~ R` 对数值进行操作

    - 加法 / 减法

      1

      ```
       + v
      ```

      2

      ```
             +v +v +v +v
      ```

      3

      ```
           [                ]
      ```

      4

      ```
             ↑         ↑
      ```

      5

      ```
             L         R
      ```

      - 朴素方法

        1

        ```
        for(i = L ; i <= R ; i ++){
        ```

        2

        ```
            a[i] += v;
        ```

        3

        ```
        }
        ```

        - 但是当操作次数，非常多的时候，导致时间超限！

          1

          ```
           for(q = 1 ; q <= 100000 ; q ++){
          ```

          2

          ```
               for(i = L ; i <= R ; i ++){
          ```

          3

          ```
                   // O(n^2)
          ```

          4

          ```
               }
          ```

          5

          ```
           }
          ```

      - 计算数值之间的差值，数值修改时，只要修改差值即可！

        1

        ```
        a:   1   2   3   4   5
        ```

        2

        ```
             ①   ②   ③   ④   ⑤        
        ```

        3

        ```
        => ② ~ ④ 每一个数值+100的操作         
        ```

        4

        ```
                 
        ```

        5

        ```
        先计算项目之间的差值： ( a[i] - a[i-1])
        ```

        6

        ```
        a:   1   2   3   4   5
        ```

        7

        ```
             ①   ②   ③   ④   ⑤  
        ```

        8

        ```
            
        ```

        9

        ```
        b:   1   1   1    1   1
        ```

        10

        ```
             ①   ②   ③    ④   ⑤  
        ```

        11

        ```
                  -+100-
        ```

        12

        ```
        => 项目之间的差值做了修改  
        ```

        13

        ```
                ② ~ ③ ③ ~ ④
        ```

        14

        ```
            |___|        |___|
        ```

        15

        ```
            ② ~ ①        ④ ~ ⑤
        ```

        16

        ```
             +100         -100
        ```

        17

        ```
            
        ```

        18

        ```
        => 重新计算了项目之间的差值：
        ```

        19

        ```
            1  101  1    1  1-100
        ```

        20

        ```
        b:  ①   ②   ③    ④   ⑤ 
        ```

        21

        ```
                |________|
        ```

        22

        ```
                L        R   R+1
        ```

        23

        ```
          b[L] + v
        ```

        24

        ```
          b[R+1] - v  
        ```

      - 还原数组

        1

        ```
        差值数值：
        ```

        2

        ```
           0   1   101    1    1    -99
        ```

        3

        ```
        b:     ①     ②    ③    ④     ⑤ 
        ```

        4

        ```
        ↓
        ```

        5

        ```
         起始位置的修改值认为是修改之后的目标值  
        ```

        6

        ```
               
        ```

        7

        ```
           0   1     101    1    1    -99
        ```

        8

        ```
        b:     ①      ②    ③    ④     ⑤ 
        ```

        9

        ```
               1     102  103  104   5
        ```

        10

        ```
        a:     ①      ②    ③    ④     ⑤  
        ```

        11

        ```
               |______|
        ```

        12

        ```
              a[1]
        ```

        13

        ```
               |_b[2]_|
        ```

        14

        ```
            
        ```

        15

        ```
          a[2] - a[1] = b[2] = 101
        ```

        16

        ```
        => a[2] = a[1] + b[2];    前缀和
        ```

        17

        ```
            
        ```

        18

        ```
            
        ```

      - 差分支持多次的标记，最后用一次的前缀和就可以得到结果

        1

        ```
           L1 ~ R1  +V1
        ```

        2

        ```
           b[L1] += V1;
        ```

        3

        ```
           b[R1+1] -= V1;    
        ```

        4

        ```
         
        ```

        5

        ```
           L2 ~ R2  -V2 
        ```

        6

        ```
           b[L2] += (-V2);
        ```

        7

        ```
           b[R2+1] -= (-V2);
        ```

  #### 					A. 倒水  			

  1

  ```
  #include <bits/stdc++.h>
  ```

  2

  ```
  using namespace std;
  ```

  3

  ```
  const int N = 1e5 + 100;
  ```

  4

  ```
  int a[N], b[N];
  ```

  5

  ```
   
  ```

  6

  ```
  int main() {
  ```

  7

  ```
   int n, k, i, l, r, v;
  ```

  8

  ```
   scanf("%d%d", &n, &k);
  ```

  9

  ```
   for (i = 1 ; i <= n ; i ++) {
  ```

  10

  ```
    scanf("%d", &a[i]);
  ```

  11

  ```
    //计算项与项之间的差值
  ```

  12

  ```
    b[i] = a[i] - a[i - 1];
  ```

  13

  ```
   }
  ```

  14

  ```
   while (k --) {
  ```

  15

  ```
    scanf("%d%d%d", &l, &r, &v);
  ```

  16

  ```
    //l ~ r
  ```

  17

  ```
    b[l] += v;
  ```

  18

  ```
    b[r + 1] -= v;
  ```

  19

  ```
   }
  ```

  20

  ```
   for (i = 1 ; i <= n ; i ++) {
  ```

  21

  ```
    // 差值计算
  ```

  22

  ```
    a[i] = a[i - 1] + b[i];
  ```

  23

  ```
    // 输出每一个修改之后的数值
  ```

  24

  ```
    printf("%d ", a[i]);
  ```

  25

  ```
   }
  ```

  26

  ```
   return 0;
  ```

  27

  ```
  }
  ```

## 			二维差分  	

- 成块修改

  1

  ```
      x1,y1--------------
  ```

  2

  ```
        |               |
  ```

  3

  ```
        |               |
  ```

  4

  ```
        |_____________ x2,y2
  ```

- 方法1

  - 转化为多行的线性修改
    - 每一行中计算差值
    - 对每一行的中的差值做修改
    - 对每一行的数值做前缀和操作

  #### 					A. 编辑子矩阵  			

  1

  ```
  #include <bits/stdc++.h>
  ```

  2

  ```
  using namespace std;
  ```

  3

  ```
  const int N = 1e3 + 10;
  ```

  4

  ```
   
  ```

  5

  ```
  int a[N][N], b[N][N];
  ```

  6

  ```
  //b:差值的记录
  ```

  7

  ```
   
  ```

  8

  ```
  int main() {
  ```

  9

  ```
   int n, k, x1, y1, x2, y2;
  ```

  10

  ```
   scanf("%d%d", &n, &k);
  ```

  11

  ```
   while (k --) {
  ```

  12

  ```
    scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
  ```

  13

  ```
    for (int i = x1 ; i <= x2 ; i ++) {
  ```

  14

  ```
     b[i][y1] += 1;
  ```

  15

  ```
     b[i][y2 + 1] -= 1;
  ```

  16

  ```
    }
  ```

  17

  ```
   }
  ```

  18

  ```
   //计算前缀和
  ```

  19

  ```
   for (int i = 1 ; i <= n ; i ++) {
  ```

  20

  ```
    //逐行的一维前缀和的求解
  ```

  21

  ```
    for (int j = 1 ; j <= n ; j ++) {
  ```

  22

  ```
     a[i][j] = a[i][j - 1] + b[i][j];
  ```

  23

  ```
     cout << a[i][j] << " ";
  ```

  24

  ```
    }
  ```

  25

  ```
    cout << endl;
  ```

  26

  ```
   }
  ```

  27

  ```
   return 0;
  ```

  28

  ```
  }
  ```

- 方法2

  ![image-20230922134614654](http://0519os.comg/%E8%B5%84%E6%96%99/%E5%AD%A6%E7%94%9F/8094/source/image-20230922134614654.png)

   

  1

  ```
  #include <bits/stdc++.h>
  ```

  2

  ```
  using namespace std;
  ```

  3

  ```
  const int N = 1e3 + 100;
  ```

  4

  ```
  int a[N][N], b[N][N];
  ```

  5

  ```
   
  ```

  6

  ```
  int main() {
  ```

  7

  ```
   int n, k, i, j, x1, y1, x2, y2;
  ```

  8

  ```
   cin >> n >> k;
  ```

  9

  ```
   for (i = 1 ; i <= k ; i ++) {
  ```

  10

  ```
    cin >> x1 >> y1 >> x2 >> y2;
  ```

  11

  ```
    //左上角标记
  ```

  12

  ```
    a[x1][y1] += 1;
  ```

  13

  ```
    a[x2 + 1][y1] -= 1;
  ```

  14

  ```
    a[x1][y2 + 1] -= 1;
  ```

  15

  ```
    a[x2 + 1][y2 + 1] += 1;
  ```

  16

  ```
   }
  ```

  17

  ```
   //二维数组前缀和
  ```

  18

  ```
   for (i = 1 ; i <= n ; i ++) {
  ```

  19

  ```
    for (j = 1 ; j <= n ; j ++) {
  ```

  20

  ```
     b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + a[i][j];
  ```

  21

  ```
    }
  ```

  22

  ```
   }
  ```

  23

  ```
   // 打印输出
  ```

  24

  ```
   for (i = 1 ; i <= n ; i ++) {
  ```

  25

  ```
    for (j = 1 ; j <= n ; j ++) {
  ```

  26

  ```
     cout <<  b[i][j] << " ";
  ```

  27

  ```
    }
  ```

  28

  ```
    cout << endl;
  ```

  29

  ```
   }
  ```

  30

  ```
   return 0;
  ```

  31

  ```
  }
  ```