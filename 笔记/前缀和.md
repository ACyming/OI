- # 	前缀和  	

  ## 			一维  	

  - 降低时间复杂度
  
    1

    ```
    O(n)
    ```

    2

    ```
        for(){
    ```

    3

    ```
            
    ```
  
    4

    ```
        }
    ```
  
    5

    ```
    O(n^2)  
    ```
  
    6

    ```
        for(){
    ```
  
    7

    ```
            for(){
    ```
  
    8

    ```
                
    ```
  
    9

    ```
            }
    ```
  
    10

    ```
        }
    ```
  
    11

    ```
     
    ```
  
    12

    ```
    O(n*log2n)  -> 二分
    ```
  
  - 计算区间和

    - `pure`

    1
  
    ```
            [                              ]
    ```

    2
  
    ```
                  ↑              ↑ 
    ```

    3
  
    ```
                  a              b
    ```

    4
  
    ```
                      
    ```

    5
  
    ```
     a ~ b
    ```

    6
  
    ```
     int s = 0;                
    ```

    7
  
    ```
     for(i = a ; i <=  b ; i ++){
    ```

    8
  
    ```
         s = s + a[i];
    ```

    9
  
    ```
     }          
    ```

    10
  
    ```
     
    ```

    11
  
    ```
    可能多次循环：
    ```

    12
  
    ```
    ① 前缀和也不能解决 跨度非常大的问题
    ```

    13
  
    ```
    ② 前缀和解决多次循环
    ```

    14
  
    ```
        //询问次数很多，但是区间范围不是非常大 =>  前缀和快速计算
    ```

    15
  
    ```
        for(i = 1 ;  i <=   9999999 ;  i ++){
    ```
  
    16
  
    ```
            cin>>x>>y;
    ```
  
    17
  
    ```
            int s = 0;
    ```
  
    18
  
    ```
            for(j = x ; j <= y ; j ++){
    ```
  
    19
  
    ```
                s = s + a[j];
    ```
  
    20
  
    ```
            }
    ```
  
    21
  
    ```
            cout<<s<<endl;
    ```
  
    22
  
    ```
        }
    ```
  
    23
  
    ```
    时间超限
    ```
  
  ### 			实现  	
  
  - 参考面积的计算
  
    ![from clipboard](http://0519os.com/Public/kindeditor/attached/image/wangshijie/wangshijie_20230908212420_89579.png)
  
    - 数值递推： 方向单调性 （从左到右 、从右往左），后项的数值不会去修改前项。
  
    - 数值规律：指定的递推公式 => 记录从 1号位置开始到达每一个位置的数值之和。
  
      1
  
      ```
       int a[N],b[N];
      ```
  
      2
  
      ```
      ...a[N]..是原始数组：  a[1] a[2] a[3] .... a[n]
      ```
  
      3
  
      ```
          
      ```
  
      4
  
      ```
      b数组中  b[i] 记录 1 ~ i 数值之和:
      ```
  
      5
  
      ```
            
      ```
  
      6
  
      ```
      b[1] = a[1];
      ```
  
      7
  
      ```
      b[2] = a[1] + a[2];                  =>  b[2] = b[1] + a[2];
      ```
  
      8
  
      ```
      b[3] = a[1] + a[2] + a[3];               b[3] = b[2] + a[3];
      ```
  
      9
  
      ```
      ...
      ```
  
      10
  
      ```
      b[n] = a[1] + ... a[n];                  b[n] = b[n-1] + a[n];
      ```
  
      11
  
      ```
       
      ```
  
      12
  
      ```
      1 ~ i 项的数值之和  =  1 ~ i - 1 项的数值之和 +  原始数组第i项结果
      ```
  
    - 依赖于线性表 (数组、`vector`)
  
    1
  
    ```
      b[i] = b[i - 1] + a[i];
    ```
  
    2
  
    ```
     
    ```
  
    3
  
    ```
     
    ```
  
    4
  
    ```
    a:              1      2      3      4      5
    ```
  
    5
  
    ```
    b:              1      3      6     10     15
    ```
  
    6
  
    ```
        --------------------------------------------
    ```
  
  - 已经计算出 1 ~ 每一项的数值之和，指定`l` ~ `r`，如何计算数值之和。
  
    1
  
    ```
        cin >>l >> r;
    ```
  
    2
  
    ```
     
    ```
  
    3
  
    ```
     int s = b[r] - b[l-1];
    ```
  
    4
  
    ```
     cout<<s;
    ```
  
     
  
  #### 			A. 连续数的和  	
  
  1
  
  ```
  n:10   k:3
  ```
  
  2
  
  ```
  i:开始位置    
  ```
  
  3
  
  ```
      1  2  3  4   5   6   7   8   9   10
  ```
  
  4
  
  ```
      1-------
  ```
  
  5
  
  ```
         ------
  ```
  
  6
  
  ```
             ------
  ```
  
  7
  
  ```
                              n-k+1--------n
  ```
  
  8
  
  ```
  枚举： k个数截取的起点     k个数之和 => 前缀和   
  ```
  
  9
  
  ```
      
  ```
  
  10
  
  ```
      l:   i
  ```
  
  11
  
  ```
   r:   i + k - 1
  ```
  
  12
  
  ```
      
  ```
  
  1
  
  ```
  #include <bits/stdc++.h>
  ```
  
  2
  
  ```
  using namespace std;
  ```
  
  3
  
  ```
  const int N = 71000;
  ```
  
  4
  
  ```
  int b[N]; // long long
  ```
  
  5
  
  ```
   
  ```
  
  6
  
  ```
  bool pfs(int x) {
  ```
  
  7
  
  ```
   return sqrt(x) == int(sqrt(x));
  ```
  
  8
  
  ```
  }
  ```
  
  9
  
  ```
   
  ```
  
  10
  
  ```
  int main() {
  ```
  
  11
  
  ```
   int n, k, i, l, r, s, c = 0;
  ```
  
  12
  
  ```
   cin >> n >> k;
  ```
  
  13
  
  ```
   for (i = 1 ; i <= n ; i ++) {
  ```
  
  14
  
  ```
    b[i] = b[i - 1] + i;
  ```
  
  15
  
  ```
   }
  ```
  
  16
  
  ```
   //枚举开始位置
  ```
  
  17
  
  ```
   for (i = 1 ; i <= n - k + 1 ; i ++) {
  ```
  
  18
  
  ```
    l = i;
  ```
  
  19
  
  ```
    r = i + k - 1;
  ```
  
  20
  
  ```
    s = b[r] - b[l - 1];
  ```
  
  21
  
  ```
    if (pfs(s)) {
  ```
  
  22
  
  ```
     c ++;
  ```
  
  23
  
  ```
    }
  ```
  
  24
  
  ```
   }
  ```
  
  25
  
  ```
   cout << c;
  ```
  
  26
  
  ```
   return 0;
  ```
  
  27
  
  ```
  }
  ```
  
  #### 			C. 计算能力  	
  
  1
  
  ```
  #include <bits/stdc++.h>
  ```
  
  2
  
  ```
  using namespace std;
  ```
  
  3
  
  ```
  const int N = 1e5 + 10;
  ```
  
  4
  
  ```
  int a[N], b[N];
  ```
  
  5
  
  ```
  int main() {
  ```
  
  6
  
  ```
   int i, n, m;
  ```
  
  7
  
  ```
   // %d => decimal十进制
  ```
  
  8
  
  ```
   scanf("%d%d", &n, &m);
  ```
  
  9
  
  ```
   for (i = 1 ;  i <= n ; i ++) {
  ```
  
  10
  
  ```
    scanf("%d", &a[i]);
  ```
  
  11
  
  ```
    b[i] = b[i - 1] + a[i];
  ```
  
  12
  
  ```
   }
  ```
  
  13
  
  ```
   int x, y;
  ```
  
  14
  
  ```
   while (m --) {
  ```
  
  15
  
  ```
    scanf("%d%d", &x, &y);
  ```
  
  16
  
  ```
    printf("%d\n", b[y] - b[x - 1]);
  ```
  
  17
  
  ```
   }
  ```
  
  18
  
  ```
   return 0;
  ```
  
  19
  
  ```
  }
  ```
  
  ## 			二维  	
  
  - 一块
  
    1
  
    ```
    [                        ]   
    ```
  
    2
  
    ```
        [x1,y1
    ```
  
    3
  
    ```
          
    ```
  
    4
  
    ```
             Sum
    ```
  
    5
  
    ```
         
    ```
  
    6
  
    ```
                    x2,y2]
    ```
  
    7
  
    ```
    [                        ]
    ```
  
  - 起始位置（1,1）到每一个坐标点的数值之和
  
    ![from clipboard](http://0519os.com/Public/kindeditor/attached/image/wangshijie/wangshijie_20230908212435_80881.png)
  
    1
  
    ```
    原始数组： a[N][M]
    ```
  
    2
  
    ```
     
    ```
  
    3
  
    ```
     [1,1] [1,2]
    ```
  
    4
  
    ```
     [2,1] [2,2] 
    ```
  
    5
  
    ```
        
    ```
  
    6
  
    ```
    b[1][1] = a[1][1];
    ```
  
    7
  
    ```
    b[1][2] = a[1][1] + a[1][2];
    ```
  
    8
  
    ```
    b[2][1] = a[1][1] + a[2][1];
    ```
  
    9
  
    ```
    b[2][2] = a[1][1] + a[1][2] + a[2][1] + a[2][2];
    ```
  
    10
  
    ```
    .....
    ```
  
    11
  
    ```
        
    ```
  
    12
  
    ```
    b[1][1] = a[1][1];
    ```
  
    13
  
    ```
    b[1][2] = b[1][1] + a[1][2];
    ```
  
    14
  
    ```
    b[2][1] = b[1][1] + a[2][1];
    ```
  
    15
  
    ```
    b[2][2] = b[1][2] + b[2][1] - b[1][1] + a[2][2];
    ```
  
    16
  
    ```
    .....
    ```
  
    17
  
    ```
        
    ```
  
    18
  
    ```
        for(){
    ```
  
    19
  
    ```
        for(){
    ```
  
    20
  
    ```
                b[i][j] = b[i-1][j] + b[i][j-1] - b[i-1][j-1] + a[i][j];
    ```
  
    21
  
    ```
            }    
    ```
  
    22
  
    ```
        }
    ```
  
  - 区间计算
  
    1
  
    ```
      x1,y1  ~  x2,y2
    ```
  
     
  
    ![from clipboard](http://0519os.com/Public/kindeditor/attached/image/wangshijie/wangshijie_20230908212445_42596.png)
  
    1
  
    ```
     int sum = b[x2][y2] - b[x1-1][y2] - b[x2][y1-1] + b[x1-1][y1-1];
    ```
  
    #### 					A. 子矩阵求和  			
  
    1
  
    ```
    #include <bits/stdc++.h>
    ```
  
    2
  
    ```
    using namespace std;
    ```
  
    3
  
    ```
    const int N = 1100;
    ```
  
    4
  
    ```
    int a[N][N], b[N][N];
    ```
  
    5
  
    ```
     
    ```
  
    6
  
    ```
    int main() {
    ```
  
    7
  
    ```
     int n, m, i, j, k;
    ```
  
    8
  
    ```
     scanf("%d%d%d", &n, &m, &k);
    ```
  
    9
  
    ```
     for (i = 1 ; i <= n ; i ++) {
    ```
  
    10
  
    ```
      for (j = 1 ; j <= m ; j ++) {
    ```
  
    11
  
    ```
       scanf("%d", &a[i][j]);
    ```
  
    12
  
    ```
       /* i-1,j-1    i-1,j
    ```
  
    13
  
    ```
           i,j-1     i,j
    ```
  
    14
  
    ```
        */
    ```
  
    15
  
    ```
       b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + a[i][j];
    ```
  
    16
  
    ```
      }
    ```
  
    17
  
    ```
     }
    ```
  
    18
  
    ```
     int x1, y1, x2, y2, sum;
    ```
  
    19
  
    ```
     while (k --) {
    ```
  
    20
  
    ```
      scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
    ```
  
    21
  
    ```
      sum = b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1];
    ```
  
    22
  
    ```
      printf("%d\n", sum);
    ```
  
    23
  
    ```
     }
    ```
  
    24
  
    ```
     return 0;
    ```
  
    25
  
    ```
    }
    ```